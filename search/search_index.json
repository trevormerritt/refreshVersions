{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Gradle refreshVersions \u00b6 Life is too short to google for dependencies and versions Why refreshVersions? \u00b6 Gradle multi-module projects are on the rise. At the same time, library vendors publish very modularized artifacts: On Android, the big fat support libraries are dead, and their replacement, AndroidX , contains more than 200 different dependencies, grouped in over 70 groups, each having its own version. (AndroidX is only a part of first-party dependencies for Android projects, and third party dependencies can add up.) On the server, many frameworks or library suites offer a high number of artifacts. That applies to Ktor, Spring, http4k and others. Again, that\u2019s not even counting third party dependencies. Both trends come with great technical benefits. However, they also make it much more tedious to find where to add and update your dependencies in all those build.gradle[.kts] files! We saw this make developers update the dependencies less and less often, effectively leading to legacy accumulation (a form of technical debt), or even projects abandon. Yes, that\u2019s sad. Can we have our cake and eat it? We firmly believe that yes, we can have the benefits of modularization without the hell of dependency management . So what does gradle refreshVersions ? Centralize your dependencies in a proper file format \u00b6 Everyone who uses Gradle in a multi-modules environment has looked for a way to centralize all dependencies in one place. And there are solutions for that. Too many solutions in fact. Some put their versions in a variable val retrofitVersion = 2.9.0 , others in rootproject.ext , others in a libraries.gradle file, others still in buildSrc/src/main/Versions.kt , and the list goes on and on! A problem common to all those solutions is that they store the versions in a turing-complete programming language (Groovy or Kotlin). Then people try to hack together regular expressions to read or modify those files. We think this is wrong! Instead, gradle refreshVersions stores all the versions in one place in a proper file format: Java Properties, like gradle.properties . Just like npm\u2019s package.json , Maven\u2019s pom.xml , this file can be easily read and written by a computer program. Yes to better tooling! No Magic! \u00b6 You wonder how this works? No black magic involved, we leverage Gradle public APIs that are designed to edit declared dependencies ( Configuration.withDependencies , and PluginManagement.resolutionStrategy ), and we edit the versions constraints there. The rest is just a set of conventions. Consider the example below: Dependency notation Version key org.gradle:gradle-hello-world-plugin:_ version.org.gradle..gradle-hello-world-plugin com.squareup.retrofit2:retrofit:_ version.retrofit com.squareup.retrofit2:retrofit-adapter-xxx:_ version.retrofit plugin with id \u201ccom.squareup.sqldelight\u201d plugin.com.squareup.sqldelight gradle refreshVersions works with an opt-in mechanism. It only manages dependencies where the version is set to be a placeholder, more specifically the underscore _ , which, akin to Kotlin, here means that the version is not used, being instead set in the versions.properties file. gradle refreshVersions has a system of rules that here, allows to set all Retrofit dependencies with the same version key version.retrofit , keeping things DRY. Look up for updates automatically \u00b6 With this infrastructure being in place, the major feature of gradle refreshVersions is like its name suggests: It will look up for all available updates of the dependencies used in the project. Simply run $ ./gradlew refreshVersions and you will see the available updates as comments : Why as comment? Because while googling manually for available updates is a monkey job that is best done by a computer program, while deciding whether to upgrade or not is your job as a programmer. Read more: Update Dependencies It\u2019s fast! \u00b6 The Kotlin Libraries Playground contains about 80 dependencies, and counting. How long would it take to search for all available updates? Well, if you do it manually: enough to hate your life . With the gradle-versions-plugin it will take about 2 minutes. With refreshVersions, you are done in 10 seconds ! See benchmarks here. Add dependencies quickly! \u00b6 gradle refreshVersions provides read-to-use organized dependency notations for popular libraries. Read more: Add Dependencies Requirements \u00b6 Gradle 6.3+ IntelliJ IDEA or Android Studio Try it out with zero setup! \u00b6 The simplest way to try out gradle refreshVersions is with our official sample, the Kotlin libraries Playground ! Everything is pre-configured here, so just open the project in IntelliJ and start adding and upgrading dependencies. Warning: You may also learn a ton of things about Kotlin libraries in the process! Funding \u2764\ufe0f \u00b6 We hope this open source project saves you a lot of time! It is maintained by its authors, Jean-Michel Fayard and Louis CAD. You can buy us more time by becoming our sponsors: \ud83d\udc9d Louis CAD GitHub Sponsors page \ud83d\udc9d Jean-Michel GitHub Sponsors page We\u2019re very grateful to you and our existing sponsors , thank you! \u2764\ufe0f\u2764\ufe0f Contributing \u00b6 If you only want to submit an issue, see this quick guide to maximize the likelihood of it being eventually resolved. If you want to submit a successful PR, start by reading our guide . License \u00b6 This project is provided under the MIT License.","title":"Overview"},{"location":"#gradle-refreshversions","text":"Life is too short to google for dependencies and versions","title":"Gradle refreshVersions"},{"location":"#why-refreshversions","text":"Gradle multi-module projects are on the rise. At the same time, library vendors publish very modularized artifacts: On Android, the big fat support libraries are dead, and their replacement, AndroidX , contains more than 200 different dependencies, grouped in over 70 groups, each having its own version. (AndroidX is only a part of first-party dependencies for Android projects, and third party dependencies can add up.) On the server, many frameworks or library suites offer a high number of artifacts. That applies to Ktor, Spring, http4k and others. Again, that\u2019s not even counting third party dependencies. Both trends come with great technical benefits. However, they also make it much more tedious to find where to add and update your dependencies in all those build.gradle[.kts] files! We saw this make developers update the dependencies less and less often, effectively leading to legacy accumulation (a form of technical debt), or even projects abandon. Yes, that\u2019s sad. Can we have our cake and eat it? We firmly believe that yes, we can have the benefits of modularization without the hell of dependency management . So what does gradle refreshVersions ?","title":"Why refreshVersions?"},{"location":"#centralize-your-dependencies-in-a-proper-file-format","text":"Everyone who uses Gradle in a multi-modules environment has looked for a way to centralize all dependencies in one place. And there are solutions for that. Too many solutions in fact. Some put their versions in a variable val retrofitVersion = 2.9.0 , others in rootproject.ext , others in a libraries.gradle file, others still in buildSrc/src/main/Versions.kt , and the list goes on and on! A problem common to all those solutions is that they store the versions in a turing-complete programming language (Groovy or Kotlin). Then people try to hack together regular expressions to read or modify those files. We think this is wrong! Instead, gradle refreshVersions stores all the versions in one place in a proper file format: Java Properties, like gradle.properties . Just like npm\u2019s package.json , Maven\u2019s pom.xml , this file can be easily read and written by a computer program. Yes to better tooling!","title":"Centralize your dependencies in a proper file format"},{"location":"#no-magic","text":"You wonder how this works? No black magic involved, we leverage Gradle public APIs that are designed to edit declared dependencies ( Configuration.withDependencies , and PluginManagement.resolutionStrategy ), and we edit the versions constraints there. The rest is just a set of conventions. Consider the example below: Dependency notation Version key org.gradle:gradle-hello-world-plugin:_ version.org.gradle..gradle-hello-world-plugin com.squareup.retrofit2:retrofit:_ version.retrofit com.squareup.retrofit2:retrofit-adapter-xxx:_ version.retrofit plugin with id \u201ccom.squareup.sqldelight\u201d plugin.com.squareup.sqldelight gradle refreshVersions works with an opt-in mechanism. It only manages dependencies where the version is set to be a placeholder, more specifically the underscore _ , which, akin to Kotlin, here means that the version is not used, being instead set in the versions.properties file. gradle refreshVersions has a system of rules that here, allows to set all Retrofit dependencies with the same version key version.retrofit , keeping things DRY.","title":"No Magic!"},{"location":"#look-up-for-updates-automatically","text":"With this infrastructure being in place, the major feature of gradle refreshVersions is like its name suggests: It will look up for all available updates of the dependencies used in the project. Simply run $ ./gradlew refreshVersions and you will see the available updates as comments : Why as comment? Because while googling manually for available updates is a monkey job that is best done by a computer program, while deciding whether to upgrade or not is your job as a programmer. Read more: Update Dependencies","title":"Look up for updates automatically"},{"location":"#its-fast","text":"The Kotlin Libraries Playground contains about 80 dependencies, and counting. How long would it take to search for all available updates? Well, if you do it manually: enough to hate your life . With the gradle-versions-plugin it will take about 2 minutes. With refreshVersions, you are done in 10 seconds ! See benchmarks here.","title":"It's fast!"},{"location":"#add-dependencies-quickly","text":"gradle refreshVersions provides read-to-use organized dependency notations for popular libraries. Read more: Add Dependencies","title":"Add dependencies quickly!"},{"location":"#requirements","text":"Gradle 6.3+ IntelliJ IDEA or Android Studio","title":"Requirements"},{"location":"#try-it-out-with-zero-setup","text":"The simplest way to try out gradle refreshVersions is with our official sample, the Kotlin libraries Playground ! Everything is pre-configured here, so just open the project in IntelliJ and start adding and upgrading dependencies. Warning: You may also learn a ton of things about Kotlin libraries in the process!","title":"Try it out with zero setup!"},{"location":"#funding","text":"We hope this open source project saves you a lot of time! It is maintained by its authors, Jean-Michel Fayard and Louis CAD. You can buy us more time by becoming our sponsors: \ud83d\udc9d Louis CAD GitHub Sponsors page \ud83d\udc9d Jean-Michel GitHub Sponsors page We\u2019re very grateful to you and our existing sponsors , thank you! \u2764\ufe0f\u2764\ufe0f","title":"Funding \u2764\ufe0f"},{"location":"#contributing","text":"If you only want to submit an issue, see this quick guide to maximize the likelihood of it being eventually resolved. If you want to submit a successful PR, start by reading our guide .","title":"Contributing"},{"location":"#license","text":"This project is provided under the MIT License.","title":"License"},{"location":"CHANGELOG/","text":"Change log for refreshVersions \u00b6 Version 0.21.0 (2021-09-07) \u00b6 New feature \u00b6 We now support npm dependencies for Kotlin/JS! Just put the version placeholder ( _ ) in place of the version, and you\u2019re good to go. The version keys follow a simple naming scheme where their id is prefixed with npm , here are two examples: - version.npm.react=17.0.2 - version.npm.@googlemaps/js-api-loader=1.12.2 Special thanks to NikkyAI who authored the feature, and pair-programmed with us to refine it! Improvements \u00b6 Before this release, when we added new dependency notations and shorter version keys, it could lead to an unwanted upgrade of the dependency in the project upgrading refreshVersions. With this release, we make sure to copy the same version if we add or change the version key, and it will also work if we decide to remove one. This ensures that upgrading refreshVersions will not be able to affect your application or library. New dependency notations: \u00b6 Koin (new group with several dependencies) Touchlab.stately (new group with several dependencies) RussHWolf.multiplatformSettings (new group with several dependencies) Version 0.20.0 (2021-08-23) \u00b6 Announcement \u00b6 We are now ready to accept dependency notation contributions for high-quality and popular dependencies from the Kotlin ecosystem! Look for issues with the Dependency notations and up-for-grabs tags to find one you can directly contribute to, or submit a new issue to ask for a new one to be added. We updated the contributing guide on the website, it now has a guide dedicated to it here . New features \u00b6 refreshVersions will now add ## unused comments on top of unused entries in the versions.properties file after you run the refreshVersions task, so you know which ones are obsolete and can be removed. The new rejectVersionsIf { \u2026 } predicate available in the refreshVersions { \u2026 } extension in your settings.gradle[.kts] file will allow you to filter any kind of versions you don\u2019t want to know about. It can be handy to filter snapshots out for example. Most of our dependency notations now provide more flexibility with 3 new extension functions: withVersionPlaceholder() , withVersion(\u2026) , and withoutVersion() . Change (potentially breaking) \u00b6 If you use a BoM from the built-in dependency notations, it must always appear before dependencies from the group it controls, or you\u2019ll see an error message that will fail the Gradle build. We do this because we can\u2019t switch on usage of the BoM for linked dependencies that have already been evaluated by Gradle. Improvements \u00b6 The refreshVersionsMigrate will now use the built-in dependency notations if they match existing dependencies. New dependency notations: \u00b6 AndroidX: benchmark.macroJunit4 core.splashscreen games: activity controller framePacing performanceTuner textInput navigation.testing wear.compose: foundation material window java rxJava2 rxJava3 testing COIL: compose composeBase Firebase: cloudMessagingDirectBoot Firebase.mlModelDownloaderKtx Firebase.mlModelDownloader Kodein.di (new group with many dependencies) Kotlin.test (which is compatible with multiplatform projects since Kotlin 1.5) KotlinX.html (compatible with multiplatform projects) Ktor.features.serialization Http4k (new group with many dependencies) Splitties.alertdialogMaterial Square okHttp3.bom okHttp3 (shortcut to existing okHttp3.okHttp) retrofit2.converter.wire retrofit2 (shortcut to existing retrofit2.retrofit) Spring (new group with many dependencies) Version 0.11.0 (2021-08-03) \u00b6 New feature \u00b6 Add task refreshVersionsMigrate that adds all missing entries in versions.properties and try to migrate the build.gradle(.kts) and other known files like libraries.gradle so that the version placeholder _ is used everywhere. Please try it out and give us your feedback for refreshVersionsMigrate Fixes \u00b6 Plugins org.jetbrains.kotlinx.benchmark should not use key version.kotlin New dependency notations \u00b6 Ktor.features.serialization AndroidX.navigation.testing Testing.kotestExtensions who replaces Testing.kotest.extensions in Kotest >= 4.5.0 Version 0.10.1 (2021-06-10) \u00b6 New features \u00b6 In Android projects, if you used the version placeholder ( _ ) directly in build.gradle(.kts) files, Android lint would trigger an unwanted warning, or error in the case of the Android build tools (aka. AGP, the Android Gradle Plugin). To avoid this inconvenience, running the refreshVersions task will now automatically check if it\u2019s running on an Android project, and in such cases, will edit (safely) the lint.xml file, creating it if needed, and add the needed rules to have these specific warnings and errors ignored. Fixes \u00b6 Add missing version placeholder ( _ ) for the Google.android.material.composeThemeAdapter dependency notation. Fix a bug that prevented from using the correct version of org.jetbrains.kotlinx.benchmark and any other Gradle plugin with an id starting with org.jetbrains.kotlinx because it matched over org.jetbrains.kotlin as well. We are now matching on org.jetbrains.kotlin. to avoid this issue. New dependency notations: \u00b6 AndroidX: emoji2 views-helper views health.servicesClient security.appAuthenticatorTesting Google.accompanist.insets.ui Version 0.10.0 (2021-05-13) \u00b6 New features \u00b6 There\u2019s a new versionFor function that takes a dependency notation, or a version key, and returns the corresponding version that is in the versions.properties file. For example, if you use Jetpack Compose, you can leverage it to set kotlinCompilerExtensionVersion with versionFor(AndroidX.compose.ui) . Groovy DSL users can find it in the Versions class. Support updates of settings plugins in settings.gradle.kts and settings.gradle files (including refreshVersions itself). Support getting versions from Google Cloud Storage backed repositories . This can be helpful if you need to update private artifacts hosted there. Thanks to NikkyAI for the contribution! Changes \u00b6 Setting up refreshVersions has been significantly simplified: Now, it\u2019s simply a plugin that must be applied in the settings.gradle.kts or settings.gradle file. Note that if you want to apply it to buildSrc as well, there\u2019s a gotcha regarding defining the version. The best thing is that on upgrade, refreshVersions will automatically replace the old & verbose bootstrap with the new plugin setup , and that works for buildSrc special case as well. We made many tests to ensure that this logic is reliable, doesn\u2019t break any code, doesn\u2019t remove important comments, and doesn\u2019t affect custom configuration in any way. Bintray sunset resiliency: If refreshVersions encounters an HTTP 403 response on a bintray repository or on jcenter, it will consider the artifact to not be in this repository instead of crashing (but you can/should still remove bintray repo declarations anyway since it has been sunset). Missing short version key rules have been added for many dependency notations groups in the Testing object, and for Orchid . Potentially breaking changes \u00b6 The fix of the Square.sqlDelight.coroutinesExtensions dependency notation can lead to such an error: Failed to resolve: coroutines-extensions-1.4.4-_ . If you get a similar error on upgrade, it\u2019s because you applied a fix like that one: Square.sqlDelight.coroutinesExtensions + \":_\" . You now can (must) remove it. A bunch of new version key rules have been added, which means you might have changes of version keys, and because we currently don\u2019t have a migration facility for those, it might cause unwanted upgrades. Consequently, especially for Android projects, we recommend checking/verifying the changes made by refreshVersions after the first Gradle sync/reload/build that follows the upgrade. Fixes \u00b6 Authentication for maven repositories should now work correctly. Should, because it can only work using internal Gradle APIs for the time being (though there\u2019s a safeguard to not crash if the API changes). Thanks to Mayank Kharbanda for the PR! Custom extraArtifactVersionKeyRules could not be taken into account if there was an overlapping rule already present in refreshVersions, even if it was more specific. That ordering issue has now been fixed, the most specific rule will now always be the one applied. If you had issues with some recent AndroidX artifacts, and their version key, they should all be fixed now, and there\u2019s all the latest dependency notations. New dependency notations \u00b6 AndroidX: activity.ktx activity.compose appSearch appSearch.compiler appSearch.localStorage biometricKtx carApp carApp.testing compose: material.ripple runtime.rxJava3 runtime.saveable ui: test testJunit4 testManifest tooling toolingData viewBinding constraintLayoutCompose core.googleShortcuts dataStore: core rxJava2 rxJava3 preferences: core rxJava2 rxJava3 hilt.navigationCompose hilt.navigationFragment leanback.paging leanback.preference leanback.tab lifecycle.viewModelCompose navigation.compose navigation.dynamicFeaturesFragment paging.compose paging.rxJava3 savedStateKtx security.appAuthenticator transitionKtx wear: complications.data complications.provider input inputTesting ongoing phoneInteractions remoteInteractions watchFace watchFace.guava watchFace.client watchFace.clientGuava watchFace.complicationsRendering watchFace.data watchFace.editor watchFace.editorGuava watchFace.style tiles: proto renderer work.multiprocess work.rxJava3 Firebase: analyticsKtx authenticationKtx cloudMessagingKtx crashlyticsKtx dynamicLinksKtx performanceMonitoringKtx Google: accompanist: appcompatTheme coil flowlayout glide imageloadingCore insets pager.indicators pager swiperefresh systemuicontroller android.material.composeThemeAdapter dagger.hilt.compiler Testing.kotest.assertions.kotlinxDateTime Special mentions \u00b6 Thanks to all the folks that joined Louis CAD in pair-programming sessions: Waqas Ahmed Benjamin Orsini Zahra Heydari Alexi Bre \u2026and of course the original author and maintainer Jean-Michel Fayard These were critical to ensure thorough testing, and great quality, all while keeping motivation to keep going. We\u2019re very grateful for your time and help, and we think our users will be as well. \ud83d\ude4f Also, thanks to all the folks that reported issues. It was very helpful to prioritize on our side. Version 0.9.7 (2020-10-16) \u00b6 Fixes \u00b6 Running the refreshVersions task twice or more would fail with \u201cexecutor rejected\u201d as an error message, until the Gradle daemon is killed. This has now been fixed. (Issue #263) The refreshVersions task was failing after the latest Gradle release candidate was superseded by the stable release because the API would return an empty JSON object after this, which we didn\u2019t expect. (Minor) We fixed a typo in a diagnostic task name ( refreshVersionsDependenciesMapping ) Version 0.9.6 (2020-10-12) \u00b6 Fixes \u00b6 This release fixes a major memory leak that would make Gradle Daemons unusable after several builds (or Gradle syncs/imports). We are very sorry for that issue, and the annoyance it might have caused. We experienced it too as users, and that\u2019s why we are bringing the fix now. We took the necessary measures to avoid future recurrence of such memory leaks. Fix of a bug that\u2019d make the first Gradle sync after adding a dependency fail. Breaking change \u00b6 If you were using Jetpack Compose, the compiler dependency had its maven coordinates changed in version 1.0.0-alpha04. We updated the AndroidX.compose.compiler dependency notation, which means it now works only for Compose 1.0.0-alpha04 and more future versions. New dependency notations \u00b6 Google.android.playServices.mlKit Google.mlKit KotlinX.serialization.json Deprecated \u00b6 Firebase ML Kit has been rebranded to Google ML Kit along with API and feature changes since 2020-08-14 update , so we deprecated the Firebase.mlKit dependencies and introduced new ones in Google.android.playServices.mlKit and Google.mlKit . New features \u00b6 refreshVersions will now warn you when Gradle is not up to date, and will give you the commands to run to update it for you to copy/paste and run. It works if you\u2019re using a release candidate, and also if you\u2019re using a nightly version! Version 0.9.5 (2020-08-21) \u00b6 This is a major release that brings surface-level and internal changes, paving the way for the upcoming 1.0 release. The plugin setup/bootstrap has changed , so check out the updated documentation in Setup . New features \u00b6 Self update discovery. RefreshVersions will check for its own updates , and add available comments in the settings.gradle[.kts] file if needed for easy upgrade. This allows you to get future improvements conveniently. Support for buildscript dependencies. It now works just like regular dependencies. First class support for buildSrc Support maven repositories with basic authentication (aka. credentials with username and password) Going forward, refreshVersions will be able to auto-migrate any breaking changes a new version would introduce in your versions.properties , build.gradle and build.gradle.kts files in. This version of refreshVersions integrates the facility to let future versions of refreshVersions that migration is needed, and from which version. This is a very important change that ensures you can keep your projects updated with the least effort possible. New dependency notations \u00b6 Kotlin.stdlib (for the base version of the stdlib) KotlinX: html Coroutines: reactive reactor rx2 rx3 Serialization: core (replaces runtime artifacts since 1.0.0-RC) protobuf cbor properties io reflect.lite nodeJs COIL , a **Co**routine **I**mage **L**oader for Android. Square: LeakCanary KotlinPoet Wire SqlDelight Moshi Picasso okio Retrofit2: Adapter: java8 (renamed from retrofitJava8) rxJava1 (renamed from retrofitRxJava1) rxJava2 (renamed from retrofitRxJava2) rxJava3 KoTest (in the Testing object) CashApp: sqlDelight (alias to Square.sqlDelight) turbine Copper Google: Dagger (including hilt for Android) Android: browserHelper JakeWharton: picnic wormholeGradlePlugin confundusGradlePlugin moshi.shimo AndroidX: Gaming Hilt startup tracing vectorDrawableSeekable Window Core: animation animationTesting Security: cryptoKtx identityCredential Compose: Runtime: dispatch savedInstance liveData rxJava2 Animation Ui Foundation Material Media2: lifecycle Concurrent: futuresKtx Dependency notations renamed \u00b6 Several dependencies notations have been renamed in this release (compared to version 0.9.4). If you were using one of the following, you\u2019ll need to migrate these usages. We recommend to use \u201cReplace in Path\u201d in IntelliJ or Android Studio, filtering for the *.gradle.kts or *.gradle file extensions to do these replacements with ease. Note that for future versions, refreshVersions will be able to do this automatically. Here\u2019s the list of renamed dependency notations: AndroidX.coreKtx -> AndroidX.core.ktx AndroidX.coreRole -> AndroidX.core.role Square.retrofit2.adapter.retrofitJava8 -> Square.retrofit2.adapter.java8 Square.retrofit2.adapter.retrofitRxJava1 -> Square.retrofit2.adapter.rxJava1 Square.retrofit2.adapter.retrofitRxJava2 -> Square.retrofit2.adapter.rxJava2 Testing.junit.junitJupiter -> Testing.junit Testing.mockK.mockK -> Testing.mockK Changes \u00b6 Make the refreshVersions task cancellable during network requests. Now, only http 404 and 401 responses from repositories will be silent. Server errors (i.e. all but http 404 and 401 responses) are now reported. Network failures are now reported. There is now a connection timeout (10 seconds per request for now) An error is reported if a dependency wasn\u2019t found in any of the configured repositories. All the searched repositories are now listed if a dependency wasn\u2019t found in any of them. Only declared repositories are now looked up. (Before, refreshVersions would search all dependencies in all repositories of all modules and their buildscript, regardless of which module was declaring them.) Dependency notation in Ktor no longer uses the native suffixed artifacts (because Kotlin 1.4 drops them, as the main ones become multiplatform) Fixes \u00b6 Version sorting would crash if a version had a long number in it. This has now been fixed, any length of digit sequence is now supported in versions. Fix maven coordinates of several dependency notations Don\u2019t crash on repositories that are not https or file or have non password credentials. The AndroidX.test.ext.jankTestHelper notation and few other ones in Firebase.mlKit had wrong maven coordinates. This has been fixed, and tests have been added to prevent it from happening again on any dependency notation we provide. Previous releases \u00b6 Change log","title":"Change Log"},{"location":"CHANGELOG/#change-log-for-refreshversions","text":"","title":"Change log for refreshVersions"},{"location":"CHANGELOG/#version-0210-2021-09-07","text":"","title":"Version 0.21.0 (2021-09-07)"},{"location":"CHANGELOG/#new-feature","text":"We now support npm dependencies for Kotlin/JS! Just put the version placeholder ( _ ) in place of the version, and you\u2019re good to go. The version keys follow a simple naming scheme where their id is prefixed with npm , here are two examples: - version.npm.react=17.0.2 - version.npm.@googlemaps/js-api-loader=1.12.2 Special thanks to NikkyAI who authored the feature, and pair-programmed with us to refine it!","title":"New feature"},{"location":"CHANGELOG/#improvements","text":"Before this release, when we added new dependency notations and shorter version keys, it could lead to an unwanted upgrade of the dependency in the project upgrading refreshVersions. With this release, we make sure to copy the same version if we add or change the version key, and it will also work if we decide to remove one. This ensures that upgrading refreshVersions will not be able to affect your application or library.","title":"Improvements"},{"location":"CHANGELOG/#new-dependency-notations","text":"Koin (new group with several dependencies) Touchlab.stately (new group with several dependencies) RussHWolf.multiplatformSettings (new group with several dependencies)","title":"New dependency notations:"},{"location":"CHANGELOG/#version-0200-2021-08-23","text":"","title":"Version 0.20.0 (2021-08-23)"},{"location":"CHANGELOG/#announcement","text":"We are now ready to accept dependency notation contributions for high-quality and popular dependencies from the Kotlin ecosystem! Look for issues with the Dependency notations and up-for-grabs tags to find one you can directly contribute to, or submit a new issue to ask for a new one to be added. We updated the contributing guide on the website, it now has a guide dedicated to it here .","title":"Announcement"},{"location":"CHANGELOG/#new-features","text":"refreshVersions will now add ## unused comments on top of unused entries in the versions.properties file after you run the refreshVersions task, so you know which ones are obsolete and can be removed. The new rejectVersionsIf { \u2026 } predicate available in the refreshVersions { \u2026 } extension in your settings.gradle[.kts] file will allow you to filter any kind of versions you don\u2019t want to know about. It can be handy to filter snapshots out for example. Most of our dependency notations now provide more flexibility with 3 new extension functions: withVersionPlaceholder() , withVersion(\u2026) , and withoutVersion() .","title":"New features"},{"location":"CHANGELOG/#change-potentially-breaking","text":"If you use a BoM from the built-in dependency notations, it must always appear before dependencies from the group it controls, or you\u2019ll see an error message that will fail the Gradle build. We do this because we can\u2019t switch on usage of the BoM for linked dependencies that have already been evaluated by Gradle.","title":"Change (potentially breaking)"},{"location":"CHANGELOG/#improvements_1","text":"The refreshVersionsMigrate will now use the built-in dependency notations if they match existing dependencies.","title":"Improvements"},{"location":"CHANGELOG/#new-dependency-notations_1","text":"AndroidX: benchmark.macroJunit4 core.splashscreen games: activity controller framePacing performanceTuner textInput navigation.testing wear.compose: foundation material window java rxJava2 rxJava3 testing COIL: compose composeBase Firebase: cloudMessagingDirectBoot Firebase.mlModelDownloaderKtx Firebase.mlModelDownloader Kodein.di (new group with many dependencies) Kotlin.test (which is compatible with multiplatform projects since Kotlin 1.5) KotlinX.html (compatible with multiplatform projects) Ktor.features.serialization Http4k (new group with many dependencies) Splitties.alertdialogMaterial Square okHttp3.bom okHttp3 (shortcut to existing okHttp3.okHttp) retrofit2.converter.wire retrofit2 (shortcut to existing retrofit2.retrofit) Spring (new group with many dependencies)","title":"New dependency notations:"},{"location":"CHANGELOG/#version-0110-2021-08-03","text":"","title":"Version 0.11.0 (2021-08-03)"},{"location":"CHANGELOG/#new-feature_1","text":"Add task refreshVersionsMigrate that adds all missing entries in versions.properties and try to migrate the build.gradle(.kts) and other known files like libraries.gradle so that the version placeholder _ is used everywhere. Please try it out and give us your feedback for refreshVersionsMigrate","title":"New feature"},{"location":"CHANGELOG/#fixes","text":"Plugins org.jetbrains.kotlinx.benchmark should not use key version.kotlin","title":"Fixes"},{"location":"CHANGELOG/#new-dependency-notations_2","text":"Ktor.features.serialization AndroidX.navigation.testing Testing.kotestExtensions who replaces Testing.kotest.extensions in Kotest >= 4.5.0","title":"New dependency notations"},{"location":"CHANGELOG/#version-0101-2021-06-10","text":"","title":"Version 0.10.1 (2021-06-10)"},{"location":"CHANGELOG/#new-features_1","text":"In Android projects, if you used the version placeholder ( _ ) directly in build.gradle(.kts) files, Android lint would trigger an unwanted warning, or error in the case of the Android build tools (aka. AGP, the Android Gradle Plugin). To avoid this inconvenience, running the refreshVersions task will now automatically check if it\u2019s running on an Android project, and in such cases, will edit (safely) the lint.xml file, creating it if needed, and add the needed rules to have these specific warnings and errors ignored.","title":"New features"},{"location":"CHANGELOG/#fixes_1","text":"Add missing version placeholder ( _ ) for the Google.android.material.composeThemeAdapter dependency notation. Fix a bug that prevented from using the correct version of org.jetbrains.kotlinx.benchmark and any other Gradle plugin with an id starting with org.jetbrains.kotlinx because it matched over org.jetbrains.kotlin as well. We are now matching on org.jetbrains.kotlin. to avoid this issue.","title":"Fixes"},{"location":"CHANGELOG/#new-dependency-notations_3","text":"AndroidX: emoji2 views-helper views health.servicesClient security.appAuthenticatorTesting Google.accompanist.insets.ui","title":"New dependency notations:"},{"location":"CHANGELOG/#version-0100-2021-05-13","text":"","title":"Version 0.10.0 (2021-05-13)"},{"location":"CHANGELOG/#new-features_2","text":"There\u2019s a new versionFor function that takes a dependency notation, or a version key, and returns the corresponding version that is in the versions.properties file. For example, if you use Jetpack Compose, you can leverage it to set kotlinCompilerExtensionVersion with versionFor(AndroidX.compose.ui) . Groovy DSL users can find it in the Versions class. Support updates of settings plugins in settings.gradle.kts and settings.gradle files (including refreshVersions itself). Support getting versions from Google Cloud Storage backed repositories . This can be helpful if you need to update private artifacts hosted there. Thanks to NikkyAI for the contribution!","title":"New features"},{"location":"CHANGELOG/#changes","text":"Setting up refreshVersions has been significantly simplified: Now, it\u2019s simply a plugin that must be applied in the settings.gradle.kts or settings.gradle file. Note that if you want to apply it to buildSrc as well, there\u2019s a gotcha regarding defining the version. The best thing is that on upgrade, refreshVersions will automatically replace the old & verbose bootstrap with the new plugin setup , and that works for buildSrc special case as well. We made many tests to ensure that this logic is reliable, doesn\u2019t break any code, doesn\u2019t remove important comments, and doesn\u2019t affect custom configuration in any way. Bintray sunset resiliency: If refreshVersions encounters an HTTP 403 response on a bintray repository or on jcenter, it will consider the artifact to not be in this repository instead of crashing (but you can/should still remove bintray repo declarations anyway since it has been sunset). Missing short version key rules have been added for many dependency notations groups in the Testing object, and for Orchid .","title":"Changes"},{"location":"CHANGELOG/#potentially-breaking-changes","text":"The fix of the Square.sqlDelight.coroutinesExtensions dependency notation can lead to such an error: Failed to resolve: coroutines-extensions-1.4.4-_ . If you get a similar error on upgrade, it\u2019s because you applied a fix like that one: Square.sqlDelight.coroutinesExtensions + \":_\" . You now can (must) remove it. A bunch of new version key rules have been added, which means you might have changes of version keys, and because we currently don\u2019t have a migration facility for those, it might cause unwanted upgrades. Consequently, especially for Android projects, we recommend checking/verifying the changes made by refreshVersions after the first Gradle sync/reload/build that follows the upgrade.","title":"Potentially breaking changes"},{"location":"CHANGELOG/#fixes_2","text":"Authentication for maven repositories should now work correctly. Should, because it can only work using internal Gradle APIs for the time being (though there\u2019s a safeguard to not crash if the API changes). Thanks to Mayank Kharbanda for the PR! Custom extraArtifactVersionKeyRules could not be taken into account if there was an overlapping rule already present in refreshVersions, even if it was more specific. That ordering issue has now been fixed, the most specific rule will now always be the one applied. If you had issues with some recent AndroidX artifacts, and their version key, they should all be fixed now, and there\u2019s all the latest dependency notations.","title":"Fixes"},{"location":"CHANGELOG/#new-dependency-notations_4","text":"AndroidX: activity.ktx activity.compose appSearch appSearch.compiler appSearch.localStorage biometricKtx carApp carApp.testing compose: material.ripple runtime.rxJava3 runtime.saveable ui: test testJunit4 testManifest tooling toolingData viewBinding constraintLayoutCompose core.googleShortcuts dataStore: core rxJava2 rxJava3 preferences: core rxJava2 rxJava3 hilt.navigationCompose hilt.navigationFragment leanback.paging leanback.preference leanback.tab lifecycle.viewModelCompose navigation.compose navigation.dynamicFeaturesFragment paging.compose paging.rxJava3 savedStateKtx security.appAuthenticator transitionKtx wear: complications.data complications.provider input inputTesting ongoing phoneInteractions remoteInteractions watchFace watchFace.guava watchFace.client watchFace.clientGuava watchFace.complicationsRendering watchFace.data watchFace.editor watchFace.editorGuava watchFace.style tiles: proto renderer work.multiprocess work.rxJava3 Firebase: analyticsKtx authenticationKtx cloudMessagingKtx crashlyticsKtx dynamicLinksKtx performanceMonitoringKtx Google: accompanist: appcompatTheme coil flowlayout glide imageloadingCore insets pager.indicators pager swiperefresh systemuicontroller android.material.composeThemeAdapter dagger.hilt.compiler Testing.kotest.assertions.kotlinxDateTime","title":"New dependency notations"},{"location":"CHANGELOG/#special-mentions","text":"Thanks to all the folks that joined Louis CAD in pair-programming sessions: Waqas Ahmed Benjamin Orsini Zahra Heydari Alexi Bre \u2026and of course the original author and maintainer Jean-Michel Fayard These were critical to ensure thorough testing, and great quality, all while keeping motivation to keep going. We\u2019re very grateful for your time and help, and we think our users will be as well. \ud83d\ude4f Also, thanks to all the folks that reported issues. It was very helpful to prioritize on our side.","title":"Special mentions"},{"location":"CHANGELOG/#version-097-2020-10-16","text":"","title":"Version 0.9.7 (2020-10-16)"},{"location":"CHANGELOG/#fixes_3","text":"Running the refreshVersions task twice or more would fail with \u201cexecutor rejected\u201d as an error message, until the Gradle daemon is killed. This has now been fixed. (Issue #263) The refreshVersions task was failing after the latest Gradle release candidate was superseded by the stable release because the API would return an empty JSON object after this, which we didn\u2019t expect. (Minor) We fixed a typo in a diagnostic task name ( refreshVersionsDependenciesMapping )","title":"Fixes"},{"location":"CHANGELOG/#version-096-2020-10-12","text":"","title":"Version 0.9.6 (2020-10-12)"},{"location":"CHANGELOG/#fixes_4","text":"This release fixes a major memory leak that would make Gradle Daemons unusable after several builds (or Gradle syncs/imports). We are very sorry for that issue, and the annoyance it might have caused. We experienced it too as users, and that\u2019s why we are bringing the fix now. We took the necessary measures to avoid future recurrence of such memory leaks. Fix of a bug that\u2019d make the first Gradle sync after adding a dependency fail.","title":"Fixes"},{"location":"CHANGELOG/#breaking-change","text":"If you were using Jetpack Compose, the compiler dependency had its maven coordinates changed in version 1.0.0-alpha04. We updated the AndroidX.compose.compiler dependency notation, which means it now works only for Compose 1.0.0-alpha04 and more future versions.","title":"Breaking change"},{"location":"CHANGELOG/#new-dependency-notations_5","text":"Google.android.playServices.mlKit Google.mlKit KotlinX.serialization.json","title":"New dependency notations"},{"location":"CHANGELOG/#deprecated","text":"Firebase ML Kit has been rebranded to Google ML Kit along with API and feature changes since 2020-08-14 update , so we deprecated the Firebase.mlKit dependencies and introduced new ones in Google.android.playServices.mlKit and Google.mlKit .","title":"Deprecated"},{"location":"CHANGELOG/#new-features_3","text":"refreshVersions will now warn you when Gradle is not up to date, and will give you the commands to run to update it for you to copy/paste and run. It works if you\u2019re using a release candidate, and also if you\u2019re using a nightly version!","title":"New features"},{"location":"CHANGELOG/#version-095-2020-08-21","text":"This is a major release that brings surface-level and internal changes, paving the way for the upcoming 1.0 release. The plugin setup/bootstrap has changed , so check out the updated documentation in Setup .","title":"Version 0.9.5 (2020-08-21)"},{"location":"CHANGELOG/#new-features_4","text":"Self update discovery. RefreshVersions will check for its own updates , and add available comments in the settings.gradle[.kts] file if needed for easy upgrade. This allows you to get future improvements conveniently. Support for buildscript dependencies. It now works just like regular dependencies. First class support for buildSrc Support maven repositories with basic authentication (aka. credentials with username and password) Going forward, refreshVersions will be able to auto-migrate any breaking changes a new version would introduce in your versions.properties , build.gradle and build.gradle.kts files in. This version of refreshVersions integrates the facility to let future versions of refreshVersions that migration is needed, and from which version. This is a very important change that ensures you can keep your projects updated with the least effort possible.","title":"New features"},{"location":"CHANGELOG/#new-dependency-notations_6","text":"Kotlin.stdlib (for the base version of the stdlib) KotlinX: html Coroutines: reactive reactor rx2 rx3 Serialization: core (replaces runtime artifacts since 1.0.0-RC) protobuf cbor properties io reflect.lite nodeJs COIL , a **Co**routine **I**mage **L**oader for Android. Square: LeakCanary KotlinPoet Wire SqlDelight Moshi Picasso okio Retrofit2: Adapter: java8 (renamed from retrofitJava8) rxJava1 (renamed from retrofitRxJava1) rxJava2 (renamed from retrofitRxJava2) rxJava3 KoTest (in the Testing object) CashApp: sqlDelight (alias to Square.sqlDelight) turbine Copper Google: Dagger (including hilt for Android) Android: browserHelper JakeWharton: picnic wormholeGradlePlugin confundusGradlePlugin moshi.shimo AndroidX: Gaming Hilt startup tracing vectorDrawableSeekable Window Core: animation animationTesting Security: cryptoKtx identityCredential Compose: Runtime: dispatch savedInstance liveData rxJava2 Animation Ui Foundation Material Media2: lifecycle Concurrent: futuresKtx","title":"New dependency notations"},{"location":"CHANGELOG/#dependency-notations-renamed","text":"Several dependencies notations have been renamed in this release (compared to version 0.9.4). If you were using one of the following, you\u2019ll need to migrate these usages. We recommend to use \u201cReplace in Path\u201d in IntelliJ or Android Studio, filtering for the *.gradle.kts or *.gradle file extensions to do these replacements with ease. Note that for future versions, refreshVersions will be able to do this automatically. Here\u2019s the list of renamed dependency notations: AndroidX.coreKtx -> AndroidX.core.ktx AndroidX.coreRole -> AndroidX.core.role Square.retrofit2.adapter.retrofitJava8 -> Square.retrofit2.adapter.java8 Square.retrofit2.adapter.retrofitRxJava1 -> Square.retrofit2.adapter.rxJava1 Square.retrofit2.adapter.retrofitRxJava2 -> Square.retrofit2.adapter.rxJava2 Testing.junit.junitJupiter -> Testing.junit Testing.mockK.mockK -> Testing.mockK","title":"Dependency notations renamed"},{"location":"CHANGELOG/#changes_1","text":"Make the refreshVersions task cancellable during network requests. Now, only http 404 and 401 responses from repositories will be silent. Server errors (i.e. all but http 404 and 401 responses) are now reported. Network failures are now reported. There is now a connection timeout (10 seconds per request for now) An error is reported if a dependency wasn\u2019t found in any of the configured repositories. All the searched repositories are now listed if a dependency wasn\u2019t found in any of them. Only declared repositories are now looked up. (Before, refreshVersions would search all dependencies in all repositories of all modules and their buildscript, regardless of which module was declaring them.) Dependency notation in Ktor no longer uses the native suffixed artifacts (because Kotlin 1.4 drops them, as the main ones become multiplatform)","title":"Changes"},{"location":"CHANGELOG/#fixes_5","text":"Version sorting would crash if a version had a long number in it. This has now been fixed, any length of digit sequence is now supported in versions. Fix maven coordinates of several dependency notations Don\u2019t crash on repositories that are not https or file or have non password credentials. The AndroidX.test.ext.jankTestHelper notation and few other ones in Firebase.mlKit had wrong maven coordinates. This has been fixed, and tests have been added to prevent it from happening again on any dependency notation we provide.","title":"Fixes"},{"location":"CHANGELOG/#previous-releases","text":"Change log","title":"Previous releases"},{"location":"add-dependencies/","text":"Add dependencies \u00b6 Use built-in dependency notations \u00b6 refreshVersions provides read-to-use organized dependency notations for select popular libraries of the following ecosystems: Kotlin Multiplatform Kotlin/JVM Android That doesn\u2019t prevent you from using refreshVersions in a Gradle project that is not using Kotlin or is not an Android project. You can use them in any build.gradle or build.gradle.kts file. Here\u2019s an example of how it looks like in the IDE: No imports needed. Autocomplete in IDE for easy discoverability. You can see all the dependency objects in this directory . Wait, what version are those dependencies using? \u00b6 All these dependency notations specify their version as the version placeholder ( _ ), so refreshVersions can replace them seamlessly with the corresponding value defined in the versions.properties file, via Gradle APIs. The same will work for your own, non-built-in dependencies if you use that same version placeholder. After adding a dependency that doesn\u2019t have its version specified in the versions.properties file yet, refreshVersions will edit it and put the most stable recent version in it on the next Gradle sync (or any other Gradle run). It will also put any less stable versions as comments, allowing you to quickly upgrade if needed. Add Gradle plugins \u00b6 This section doesn\u2019t apply to plugins that are configured in a buildscript block (since these have their versions configured like regular dependencies), but only to those that are configured solely with a plugin id. To add such a plugin, do as usual, but do not specify the version in the build.gradle or build.gradle.kts file. Instead, set it up like so in the versions.properties file: versions.properties plugin.com.apollographql.apollo = 2.4.1 plugin.com.squareup.sqldelight = 1.4.3 Then you can omit the plugin version in all build.gradle(.kts) of your project: some-module/build.gradle.kts plugins { id ( \"com.squareup.sqldelight\" ) id ( \"com.apollographql.apollo\" ) } some-module/build.gradle plugins { id 'com.squareup.sqldelight' id 'com.apollographql.apollo' } As you see, the convention is pretty simple. The key is the id of the plugin, prefixed by plugin. : plugin.some.plugin.id sets the version of the plugin of id some.plugin.id . Get the version from anywhere \u00b6 In some cases, you might need to get the version defined in the versions.properties file in a Gradle script. For these cases, there\u2019s the versionFor function that takes either a version key, or a full dependency notation. Here\u2019s a usage example with Jetpack Compose in an Android project: build.gradle.kts import de.fayard.refreshVersions.core.versionFor ... composeOptions { kotlinCompilerExtensionVersion = versionFor ( AndroidX . compose . ui ) } build.gradle import static de . fayard . refreshVersions . core . Versions . versionFor ... composeOptions { kotlinCompilerExtensionVersion = versionFor ( AndroidX . compose . ui ) } Using versionFor(\"version.androidx.compose.ui\") would also work, so long as version.androidx.compose.ui is defined in the versions.properties file. Non-built-in dependency notations \u00b6 Generally speaking, so long as you have the version placeholder ( _ ) in place of the version, refreshVersions will handle it. Below are some ways to deal with the dependency notations that are not built-in. Using buildSrcLibs \u00b6 The Gradle task buildSrcLibs can be used to automatically generate a Libs.kt file in the buildSrc , that will contain all the dependency notations curently used in your build. To use it, you need to enable it: settings.gradle.kts plugins { // See https://jmfayard.github.io/refreshVersions id ( \"de.fayard.refreshVersions\" ) version \"0.21.0\" } refreshVersions { enableBuildSrcLibs () // <-- Add this } settings.gradle plugins { // See https://jmfayard.github.io/refreshVersions id 'de.fayard.refreshVersions' version '0.21.0' } refreshVersions { enableBuildSrcLibs () // <-- Add this } Then you can use the command ./gradlew buildSrcLibs to generate accessors for your dependencies $ ./gradlew buildSrcLibs > Task :buildSrcLibs new file: buildSrc/build.gradle.kts new file: buildSrc/src/main/kotlin/Libs.kt The generated file will look like this: buildSrc/src/main/kotlin/Libs.kt /** * Generated by `$ ./gradlew buildSrcLibs` */ object Libs { const val guava : String = \"com.google.guava:guava:_\" const val guice : String = \"com.google.inject:guice:_\" } Because this file uses the version placeholder ( _ ), it is compatible with refreshVersions! Read more: gradle buildSrcVersions . Using Package Search from JetBrains \u00b6 JetBrains offers the plugin Package Search , it is compatible with both IntelliJ IDEA and Android Studio. It also has a website Package Search provides a nice UX to add a dependency: Can you use it with refreshVersions? Sure, just use the version placeholder ( _ ). Using Gradle 7+ Versions Catalogs \u00b6 Gradle 7 comes with its own feature for centralizing dependencies: Versions Catalogs . With Versions Catalog, you have a file like gradle/libs.versions.toml where you can centralize all your dependencies and benefit from typesafe accessors in your build.gradle[.kts] file. Since the feature is incubating, you need to enable it explicitly in the project\u2019s settings.gradle[.kts] file: enableFeaturePreview(\"VERSION_CATALOGS\") Does that work well with refreshVersions? Yes, as long as you use the version placeholder ( _ ). gradle/libs.versions.toml [libraries] accompanist-coil = \"com.google.accompanist:accompanist-coil:_\" accompanist-flowlayout = \"com.google.accompanist:accompanist-flowlayout:_\" accompanist-insets = \"com.google.accompanist:accompanist-insets:_\" ... In this configuration, the versions catalog centralizes the dependency notations, while refreshVersions takes care of setting and updating the versions. We have ideas to integrate Versions Catalogs deeper into refreshVersions, see this issue . Using the libraries.gradle pattern \u00b6 An older approach to centralize dependencies is to have a libraries.gradle file: libraries.gradle ext . libraries = [ // Groovy map literal spring_core: \"org.springframework:spring-core:3.1\" , junit: \"junit:junit:4.10\" ] some-module/build.gradle apply ( from = \"../libraries.gradle\" ) dependencies { compile libraries . spring_core testCompile libraries . junit } Does that work with refreshVersions too? Yes, just use the version placeholder ( _ ): libraries.gradle ext.libraries = [ // Groovy map literal - spring_core: \"org.springframework:spring-core:3.1\", + spring_core: \"org.springframework:spring-core:_\", - junit: \"junit:junit:4.10\" + junit: \"junit:junit:_\" ]","title":"Add Dependencies"},{"location":"add-dependencies/#add-dependencies","text":"","title":"Add dependencies"},{"location":"add-dependencies/#use-built-in-dependency-notations","text":"refreshVersions provides read-to-use organized dependency notations for select popular libraries of the following ecosystems: Kotlin Multiplatform Kotlin/JVM Android That doesn\u2019t prevent you from using refreshVersions in a Gradle project that is not using Kotlin or is not an Android project. You can use them in any build.gradle or build.gradle.kts file. Here\u2019s an example of how it looks like in the IDE: No imports needed. Autocomplete in IDE for easy discoverability. You can see all the dependency objects in this directory .","title":"Use built-in dependency notations"},{"location":"add-dependencies/#wait-what-version-are-those-dependencies-using","text":"All these dependency notations specify their version as the version placeholder ( _ ), so refreshVersions can replace them seamlessly with the corresponding value defined in the versions.properties file, via Gradle APIs. The same will work for your own, non-built-in dependencies if you use that same version placeholder. After adding a dependency that doesn\u2019t have its version specified in the versions.properties file yet, refreshVersions will edit it and put the most stable recent version in it on the next Gradle sync (or any other Gradle run). It will also put any less stable versions as comments, allowing you to quickly upgrade if needed.","title":"Wait, what version are those dependencies using?"},{"location":"add-dependencies/#add-gradle-plugins","text":"This section doesn\u2019t apply to plugins that are configured in a buildscript block (since these have their versions configured like regular dependencies), but only to those that are configured solely with a plugin id. To add such a plugin, do as usual, but do not specify the version in the build.gradle or build.gradle.kts file. Instead, set it up like so in the versions.properties file: versions.properties plugin.com.apollographql.apollo = 2.4.1 plugin.com.squareup.sqldelight = 1.4.3 Then you can omit the plugin version in all build.gradle(.kts) of your project: some-module/build.gradle.kts plugins { id ( \"com.squareup.sqldelight\" ) id ( \"com.apollographql.apollo\" ) } some-module/build.gradle plugins { id 'com.squareup.sqldelight' id 'com.apollographql.apollo' } As you see, the convention is pretty simple. The key is the id of the plugin, prefixed by plugin. : plugin.some.plugin.id sets the version of the plugin of id some.plugin.id .","title":"Add Gradle plugins"},{"location":"add-dependencies/#get-the-version-from-anywhere","text":"In some cases, you might need to get the version defined in the versions.properties file in a Gradle script. For these cases, there\u2019s the versionFor function that takes either a version key, or a full dependency notation. Here\u2019s a usage example with Jetpack Compose in an Android project: build.gradle.kts import de.fayard.refreshVersions.core.versionFor ... composeOptions { kotlinCompilerExtensionVersion = versionFor ( AndroidX . compose . ui ) } build.gradle import static de . fayard . refreshVersions . core . Versions . versionFor ... composeOptions { kotlinCompilerExtensionVersion = versionFor ( AndroidX . compose . ui ) } Using versionFor(\"version.androidx.compose.ui\") would also work, so long as version.androidx.compose.ui is defined in the versions.properties file.","title":"Get the version from anywhere"},{"location":"add-dependencies/#non-built-in-dependency-notations","text":"Generally speaking, so long as you have the version placeholder ( _ ) in place of the version, refreshVersions will handle it. Below are some ways to deal with the dependency notations that are not built-in.","title":"Non-built-in dependency notations"},{"location":"add-dependencies/#using-buildsrclibs","text":"The Gradle task buildSrcLibs can be used to automatically generate a Libs.kt file in the buildSrc , that will contain all the dependency notations curently used in your build. To use it, you need to enable it: settings.gradle.kts plugins { // See https://jmfayard.github.io/refreshVersions id ( \"de.fayard.refreshVersions\" ) version \"0.21.0\" } refreshVersions { enableBuildSrcLibs () // <-- Add this } settings.gradle plugins { // See https://jmfayard.github.io/refreshVersions id 'de.fayard.refreshVersions' version '0.21.0' } refreshVersions { enableBuildSrcLibs () // <-- Add this } Then you can use the command ./gradlew buildSrcLibs to generate accessors for your dependencies $ ./gradlew buildSrcLibs > Task :buildSrcLibs new file: buildSrc/build.gradle.kts new file: buildSrc/src/main/kotlin/Libs.kt The generated file will look like this: buildSrc/src/main/kotlin/Libs.kt /** * Generated by `$ ./gradlew buildSrcLibs` */ object Libs { const val guava : String = \"com.google.guava:guava:_\" const val guice : String = \"com.google.inject:guice:_\" } Because this file uses the version placeholder ( _ ), it is compatible with refreshVersions! Read more: gradle buildSrcVersions .","title":"Using buildSrcLibs"},{"location":"add-dependencies/#using-package-search-from-jetbrains","text":"JetBrains offers the plugin Package Search , it is compatible with both IntelliJ IDEA and Android Studio. It also has a website Package Search provides a nice UX to add a dependency: Can you use it with refreshVersions? Sure, just use the version placeholder ( _ ).","title":"Using Package Search from JetBrains"},{"location":"add-dependencies/#using-gradle-7-versions-catalogs","text":"Gradle 7 comes with its own feature for centralizing dependencies: Versions Catalogs . With Versions Catalog, you have a file like gradle/libs.versions.toml where you can centralize all your dependencies and benefit from typesafe accessors in your build.gradle[.kts] file. Since the feature is incubating, you need to enable it explicitly in the project\u2019s settings.gradle[.kts] file: enableFeaturePreview(\"VERSION_CATALOGS\") Does that work well with refreshVersions? Yes, as long as you use the version placeholder ( _ ). gradle/libs.versions.toml [libraries] accompanist-coil = \"com.google.accompanist:accompanist-coil:_\" accompanist-flowlayout = \"com.google.accompanist:accompanist-flowlayout:_\" accompanist-insets = \"com.google.accompanist:accompanist-insets:_\" ... In this configuration, the versions catalog centralizes the dependency notations, while refreshVersions takes care of setting and updating the versions. We have ideas to integrate Versions Catalogs deeper into refreshVersions, see this issue .","title":"Using Gradle 7+ Versions Catalogs"},{"location":"add-dependencies/#using-the-librariesgradle-pattern","text":"An older approach to centralize dependencies is to have a libraries.gradle file: libraries.gradle ext . libraries = [ // Groovy map literal spring_core: \"org.springframework:spring-core:3.1\" , junit: \"junit:junit:4.10\" ] some-module/build.gradle apply ( from = \"../libraries.gradle\" ) dependencies { compile libraries . spring_core testCompile libraries . junit } Does that work with refreshVersions too? Yes, just use the version placeholder ( _ ): libraries.gradle ext.libraries = [ // Groovy map literal - spring_core: \"org.springframework:spring-core:3.1\", + spring_core: \"org.springframework:spring-core:_\", - junit: \"junit:junit:4.10\" + junit: \"junit:junit:_\" ]","title":"Using the libraries.gradle pattern"},{"location":"gradle-buildsrcversions/","text":"The buildSrc module \u00b6 The buildSrc is a Gradle module where you can write Kotlin code (with full tooling support). That code is then be available to all your build files - not your final application. One cool thing you can do with it is to replace those libraries.gradle files we used to write: buildSrc/src/main/kotlin/Libs.kt object Libs { const val okhttp = \"com.squareup.okhttp3:okhttp:\" + Versions . okhttp const val okio = \"com.squareup.okio:okio:\" + Versions . okio } buildSrc/src/main/kotlin/Versions.kt object Versions { const val okhttp = \"3.12.1\" const val okio = \"2.0.0\" } The crucial difference was that IntelliJ IDEA and Android Studio have good support for calling it from build.gradle[.kts] Finally the IDE tooling we deserve: auto-completion jumping to definition \u2026 \u201cgradle buildSrcVersions\u201d is dead\u2026 \u00b6 The ancestor of the plugin refreshVersions was a plugin called buildSrcVersions . What it did was to auto-generate the buildSrc/.../{Libs,Versions}.kt files above! $ ./gradlew buildSrcVersions > Task :buildSrcVersions new file: buildSrc/build.gradle.kts new file: buildSrc/.gitignore new file: buildSrc/src/main/kotlin/Libs.kt new file: buildSrc/src/main/kotlin/Versions.kt \u2026long life \u201cgradle buildSrcLibs\u201d! \u00b6 The Versions.kt file was replaced by a technically better solution, the versions.properties file. That said, the Libs.kt file still has its use cases, so in your settings.gradle(.kts) file, you can add the following: refreshVersions { enableBuildSrcLibs () } That will enable the task buildSrcLibs , which also has an alias: buildSrcVersions for easier transition for existing users. Use it like this: $ ./gradlew buildSrcLibs > Task :buildSrcLibs new file: versions.properties new file: buildSrc/src/main/kotlin/Libs.kt The task generates what you expect: versions.properties version.okhttp = 3.12.1 version.okio = 2.0.0 buildSrc/src/main/kotlin/Libs.kt object Libs { const val okhttp = \"com.squareup.okhttp3:okhttp:_\" const val okio = \"com.squareup.okio:okio:_\" } The constants generated in Libs.kt have the same name as they had in the buildSrcVersions plugin . This makes updating to refreshVersions pretty straightforward. Replace your dependencies \u00b6 First, reload/sync your Gradle project in the IDE. You can now start to replace your magic strings with the properties available in Libs.kt Update dependencies \u00b6 You can still automatically look for updates, but this is now done with the task refreshVersions and editing the file versions.properties $ ./gradlew refreshVersions Read more: Update dependencies .","title":"Gradle buildsrcversions"},{"location":"gradle-buildsrcversions/#the-buildsrc-module","text":"The buildSrc is a Gradle module where you can write Kotlin code (with full tooling support). That code is then be available to all your build files - not your final application. One cool thing you can do with it is to replace those libraries.gradle files we used to write: buildSrc/src/main/kotlin/Libs.kt object Libs { const val okhttp = \"com.squareup.okhttp3:okhttp:\" + Versions . okhttp const val okio = \"com.squareup.okio:okio:\" + Versions . okio } buildSrc/src/main/kotlin/Versions.kt object Versions { const val okhttp = \"3.12.1\" const val okio = \"2.0.0\" } The crucial difference was that IntelliJ IDEA and Android Studio have good support for calling it from build.gradle[.kts] Finally the IDE tooling we deserve: auto-completion jumping to definition \u2026","title":"The buildSrc module"},{"location":"gradle-buildsrcversions/#gradle-buildsrcversions-is-dead","text":"The ancestor of the plugin refreshVersions was a plugin called buildSrcVersions . What it did was to auto-generate the buildSrc/.../{Libs,Versions}.kt files above! $ ./gradlew buildSrcVersions > Task :buildSrcVersions new file: buildSrc/build.gradle.kts new file: buildSrc/.gitignore new file: buildSrc/src/main/kotlin/Libs.kt new file: buildSrc/src/main/kotlin/Versions.kt","title":"\"gradle buildSrcVersions\" is dead\u2026"},{"location":"gradle-buildsrcversions/#long-life-gradle-buildsrclibs","text":"The Versions.kt file was replaced by a technically better solution, the versions.properties file. That said, the Libs.kt file still has its use cases, so in your settings.gradle(.kts) file, you can add the following: refreshVersions { enableBuildSrcLibs () } That will enable the task buildSrcLibs , which also has an alias: buildSrcVersions for easier transition for existing users. Use it like this: $ ./gradlew buildSrcLibs > Task :buildSrcLibs new file: versions.properties new file: buildSrc/src/main/kotlin/Libs.kt The task generates what you expect: versions.properties version.okhttp = 3.12.1 version.okio = 2.0.0 buildSrc/src/main/kotlin/Libs.kt object Libs { const val okhttp = \"com.squareup.okhttp3:okhttp:_\" const val okio = \"com.squareup.okio:okio:_\" } The constants generated in Libs.kt have the same name as they had in the buildSrcVersions plugin . This makes updating to refreshVersions pretty straightforward.","title":"\u2026long life \"gradle buildSrcLibs\"!"},{"location":"gradle-buildsrcversions/#replace-your-dependencies","text":"First, reload/sync your Gradle project in the IDE. You can now start to replace your magic strings with the properties available in Libs.kt","title":"Replace your dependencies"},{"location":"gradle-buildsrcversions/#update-dependencies","text":"You can still automatically look for updates, but this is now done with the task refreshVersions and editing the file versions.properties $ ./gradlew refreshVersions Read more: Update dependencies .","title":"Update dependencies"},{"location":"gradle-tips/","text":"Gradle tips and tricks \u00b6 More information to make your build great again! Switch to the Kotlin DSL \u00b6 Groovy was there first in Gradle, but consider switching to Kotlin if you have not done so already. The cryptic error messages will go away, and the IDE support is far superior. Hello auto-complete! How Kotlin makes editing your Gradle build less frustrating Consider using the Gradle build scan \u00b6 Given the range of information it gives you about your build, it\u2019s a no-brainer to use the build scan if you are working an open-source project or have a Gradle Enterprise account. For a company project, understands the trade off of having this information potentially shared by someone outside. It has to be configured in settings.gradle[.kts] // https://dev.to/jmfayard/the-one-gradle-trick-that-supersedes-all-the-others-5bpg plugins { id ( \"com.gradle.enterprise\" ). version ( VERSION ) } gradleEnterprise { buildScan { // Accept the license agreement for com.gradle.build-scan plugin termsOfServiceUrl = \"https://gradle.com/terms-of-service\" termsOfServiceAgree = \"yes\" publishOnFailure () } } Find VERSION at https://plugins.gradle.org/plugin/com.gradle.enterprise Build scan - the one Gradle trick that supersedes all the others Configure Gradle with gradle.properties \u00b6 You need to put some magic property with some magic value in gradle.properties, but which one? Configure Gradle with Gradle Properties Set-up GitHub Actions with Gradle \u00b6 A simple workflow to get you up and running with continuous integration. copy-paste .github/worrkflows/runOnGitHub.yml create a Gradle task called runOnGitHub create a pull request, and you are good to go! How do I set up GitHub Actions for my Gradle or Android project? More complex workflows can be found in the repositories refreshVersions and Splitties Gradle Settings \u00b6 A Gradle project has a Settings file called settings.gradle or settings.gradle.kts where you must respect a certain order (otherwise, the build breaks). The order is: imports, if any. The pluginManagement block, if any. The buildscript block, if any. (We will use it) The plugins block, if any settings plugins are applied. Logic for Gradle settings (any other code). See the example snippet below: import com.example.something // Imports at the top, as usual. pluginManagement {} // Optional buildscript { // We will setup refreshVersions here, see below. } plugins { // Optional id ( \"de.fayard.refreshVersions\" ) version \"0.10.0\" // other plugins like the Gradle Entreprise plugin go here } refreshVersions { // Optional configuration } // Then you can have other code after the blocks above, rootProject . name = \"My Project\" // Optional, defaults to parent dir's name. include ( \":app\" ) // If the project has modules/subprojects to declare.","title":"Bonus: Gradle tips and tricks"},{"location":"gradle-tips/#gradle-tips-and-tricks","text":"More information to make your build great again!","title":"Gradle tips and tricks"},{"location":"gradle-tips/#switch-to-the-kotlin-dsl","text":"Groovy was there first in Gradle, but consider switching to Kotlin if you have not done so already. The cryptic error messages will go away, and the IDE support is far superior. Hello auto-complete! How Kotlin makes editing your Gradle build less frustrating","title":"Switch to the Kotlin DSL"},{"location":"gradle-tips/#consider-using-the-gradle-build-scan","text":"Given the range of information it gives you about your build, it\u2019s a no-brainer to use the build scan if you are working an open-source project or have a Gradle Enterprise account. For a company project, understands the trade off of having this information potentially shared by someone outside. It has to be configured in settings.gradle[.kts] // https://dev.to/jmfayard/the-one-gradle-trick-that-supersedes-all-the-others-5bpg plugins { id ( \"com.gradle.enterprise\" ). version ( VERSION ) } gradleEnterprise { buildScan { // Accept the license agreement for com.gradle.build-scan plugin termsOfServiceUrl = \"https://gradle.com/terms-of-service\" termsOfServiceAgree = \"yes\" publishOnFailure () } } Find VERSION at https://plugins.gradle.org/plugin/com.gradle.enterprise Build scan - the one Gradle trick that supersedes all the others","title":"Consider using the Gradle build scan"},{"location":"gradle-tips/#configure-gradle-with-gradleproperties","text":"You need to put some magic property with some magic value in gradle.properties, but which one? Configure Gradle with Gradle Properties","title":"Configure Gradle with gradle.properties"},{"location":"gradle-tips/#set-up-github-actions-with-gradle","text":"A simple workflow to get you up and running with continuous integration. copy-paste .github/worrkflows/runOnGitHub.yml create a Gradle task called runOnGitHub create a pull request, and you are good to go! How do I set up GitHub Actions for my Gradle or Android project? More complex workflows can be found in the repositories refreshVersions and Splitties","title":"Set-up GitHub Actions with Gradle"},{"location":"gradle-tips/#gradle-settings","text":"A Gradle project has a Settings file called settings.gradle or settings.gradle.kts where you must respect a certain order (otherwise, the build breaks). The order is: imports, if any. The pluginManagement block, if any. The buildscript block, if any. (We will use it) The plugins block, if any settings plugins are applied. Logic for Gradle settings (any other code). See the example snippet below: import com.example.something // Imports at the top, as usual. pluginManagement {} // Optional buildscript { // We will setup refreshVersions here, see below. } plugins { // Optional id ( \"de.fayard.refreshVersions\" ) version \"0.10.0\" // other plugins like the Gradle Entreprise plugin go here } refreshVersions { // Optional configuration } // Then you can have other code after the blocks above, rootProject . name = \"My Project\" // Optional, defaults to parent dir's name. include ( \":app\" ) // If the project has modules/subprojects to declare.","title":"Gradle Settings"},{"location":"migrate/","text":"Migrate \u00b6 Migrating an existing project to refreshVersions manually is tricky: Existing dependencies are ignored because they don\u2019t use the version placeholder _ . Replacing the harcoded version with the version placeholder is not what you want, because it has the major side effect to upgrade all your dependencies to whatever is the latest version available. Starting with refreshVersions 0.11.0, we provide an experimental interactive Gradle task made for migration. First, ensure you are using the plugin\u2019s latest version: settings.gradle.kts plugins { // See https://jmfayard.github.io/refreshVersions id ( \"de.fayard.refreshVersions\" ) version \"0.21.0\" } settings.gradle plugins { // See https://jmfayard.github.io/refreshVersions id 'de.fayard.refreshVersions' version '0.21.0' } Migrate semi-automatically \u00b6 The new task refreshVersionsMigrate takes care of the migration semi-automatically: ./gradlew refreshVersionsMigrate You should see something like this: > Task :refreshVersionsMigrate modified: versions.properties modified: build.gradle.kts modified: gradle/libraries.gradle To find available updates, run this: ./gradlew refreshVersions At that point, you probably want to have a look at the git diff to see what changed. As you can see: It generates versions.properties with the current version of all dependencies. It modifies build.gradle(.kts) files and other files like libraries.gradle or buildSrc/src/main/kotlin/Libs.kt known to contain dependency notations, so that the version placeholder _ is used everywhere. Please try it out and give us here your feedback for refreshVersionsMigrate \ud83d\udc4d\ud83c\udffc .","title":"Migrate"},{"location":"migrate/#migrate","text":"Migrating an existing project to refreshVersions manually is tricky: Existing dependencies are ignored because they don\u2019t use the version placeholder _ . Replacing the harcoded version with the version placeholder is not what you want, because it has the major side effect to upgrade all your dependencies to whatever is the latest version available. Starting with refreshVersions 0.11.0, we provide an experimental interactive Gradle task made for migration. First, ensure you are using the plugin\u2019s latest version: settings.gradle.kts plugins { // See https://jmfayard.github.io/refreshVersions id ( \"de.fayard.refreshVersions\" ) version \"0.21.0\" } settings.gradle plugins { // See https://jmfayard.github.io/refreshVersions id 'de.fayard.refreshVersions' version '0.21.0' }","title":"Migrate"},{"location":"migrate/#migrate-semi-automatically","text":"The new task refreshVersionsMigrate takes care of the migration semi-automatically: ./gradlew refreshVersionsMigrate You should see something like this: > Task :refreshVersionsMigrate modified: versions.properties modified: build.gradle.kts modified: gradle/libraries.gradle To find available updates, run this: ./gradlew refreshVersions At that point, you probably want to have a look at the git diff to see what changed. As you can see: It generates versions.properties with the current version of all dependencies. It modifies build.gradle(.kts) files and other files like libraries.gradle or buildSrc/src/main/kotlin/Libs.kt known to contain dependency notations, so that the version placeholder _ is used everywhere. Please try it out and give us here your feedback for refreshVersionsMigrate \ud83d\udc4d\ud83c\udffc .","title":"Migrate semi-automatically"},{"location":"setup/","text":"Setup \u00b6 This guide will help you set up refreshVersions in a Gradle project. Update Gradle (if needed) \u00b6 Only Gradle 6.3+ is supported at the moment, because there were a lot of changes in dependencies management in Gradle 6, and other compatibility concerns. It also allows for a simpler setup for plugins for example. Updating Gradle is anyway usually a good idea. You get fewer bugs, more features, and faster builds. Run this command to update: ./gradlew wrapper --gradle-version 6 .9 You should also try to update the Gradle plugins present in your build to the latest version. For example on an Android project, do update the version of the Gradle Android Plugin. The Gradle documentation has detailed migration guide if you are stuck: From Gradle 6+: https://docs.gradle.org/current/userguide/upgrading_version_6.html From Gradle 5.x: https://docs.gradle.org/current/userguide/upgrading_version_5.html From Gradle 4.x: https://docs.gradle.org/current/userguide/upgrading_version_4.html Add the plugin \u00b6 Here is how to configure gradle refreshVersions: settings.gradle.kts plugins { // See https://jmfayard.github.io/refreshVersions id ( \"de.fayard.refreshVersions\" ) version \"0.21.0\" } settings.gradle plugins { // See https://jmfayard.github.io/refreshVersions id 'de.fayard.refreshVersions' version '0.21.0' } If you have a buildSrc module \u00b6 If you use the buildSrc module and have dependencies declared in the buildSrc/build.gradle[.kts] file, you probably want to use refreshVersions there as well. The setup is the same: buildSrc/settings.gradle.kts pluginManagement { plugins { id ( \"de.fayard.refreshVersions\" ) version \"0.21.0\" } } plugins { id ( \"de.fayard.refreshVersions\" ) } buildSrc/settings.gradle pluginManagement { plugins { id 'de.fayard.refreshVersions' version '0.21.0' } } plugins { id 'de.fayard.refreshVersions' } If you use Groovy DSL, i.e. build.gradle files (not kts) \u00b6 Auto-completion for dependency notations won\u2019t work out of the box. A workaround is to configure the plugin in the buildSrc module (create the directory if it doesn\u2019t exist yet): buildSrc/settings.gradle pluginManagement { plugins { id 'de.fayard.refreshVersions' version '0.21.0' } } plugins { id 'de.fayard.refreshVersions' } If you have a composite/included build \u00b6 Sharing used versions with included builds is not supported at the moment. If you need/want this feature, please vote with a \ud83d\udc4d on this issue , subscribe to it, and tell us about your use case, to help us prioritize. If you want to use a snapshot version \u00b6 settings.gradle.kts pluginManagement { repositories { gradlePluginPortal () maven ( \"https://s01.oss.sonatype.org/content/repositories/snapshots\" ) } } plugins { // See https://jmfayard.github.io/refreshVersions id ( \"de.fayard.refreshVersions\" ) version \"0.21.1-SNAPSHOT\" } settings.gradle pluginManagement { repositories { gradlePluginPortal () maven { url 'https://s01.oss.sonatype.org/content/repositories/snapshots' } } } plugins { // See https://jmfayard.github.io/refreshVersions id 'de.fayard.refreshVersions' version '0.21.1-SNAPSHOT' } Configure the plugin \u00b6 There is no required configuration! There are some options which can be configured in the refreshVersions { } block. If you are curious about what are the available options, you can use auto-complete (you can also type this. before to filter the results). Earlier versions \u00b6 If you are upgrading from the buildSrcVersions plugin \u00b6 Before refreshVersions, there was the plugin buildSrcVersions . If your project is using it, remove all its configuration from the top build.gradle[.kts] file to avoid any clashes between the two plugins: build.gradle.kts -plugins { - id(\"de.fayard.buildSrcVersions\") version \"0.3.2\" -} -buildSrcVersions { - someOption = \"somevalue\" -} Then, enable buildSrcLibs as such: settings.gradle.kts plugins { // See https://jmfayard.github.io/refreshVersions id ( \"de.fayard.refreshVersions\" ) version \"0.21.0\" } refreshVersions { enableBuildSrcLibs () // <-- Add this } settings.gradle plugins { // See https://jmfayard.github.io/refreshVersions id 'de.fayard.refreshVersions' version '0.21.0' } refreshVersions { enableBuildSrcLibs () // <-- Add this } Read more: gradle buildSrcVersions . Next steps \u00b6 You did it! refreshVersions is now properly setup. Now, you might want to: Migrate your project . Add new dependencies . Update dependencies .","title":"Setup"},{"location":"setup/#setup","text":"This guide will help you set up refreshVersions in a Gradle project.","title":"Setup"},{"location":"setup/#update-gradle-if-needed","text":"Only Gradle 6.3+ is supported at the moment, because there were a lot of changes in dependencies management in Gradle 6, and other compatibility concerns. It also allows for a simpler setup for plugins for example. Updating Gradle is anyway usually a good idea. You get fewer bugs, more features, and faster builds. Run this command to update: ./gradlew wrapper --gradle-version 6 .9 You should also try to update the Gradle plugins present in your build to the latest version. For example on an Android project, do update the version of the Gradle Android Plugin. The Gradle documentation has detailed migration guide if you are stuck: From Gradle 6+: https://docs.gradle.org/current/userguide/upgrading_version_6.html From Gradle 5.x: https://docs.gradle.org/current/userguide/upgrading_version_5.html From Gradle 4.x: https://docs.gradle.org/current/userguide/upgrading_version_4.html","title":"Update Gradle (if needed)"},{"location":"setup/#add-the-plugin","text":"Here is how to configure gradle refreshVersions: settings.gradle.kts plugins { // See https://jmfayard.github.io/refreshVersions id ( \"de.fayard.refreshVersions\" ) version \"0.21.0\" } settings.gradle plugins { // See https://jmfayard.github.io/refreshVersions id 'de.fayard.refreshVersions' version '0.21.0' }","title":"Add the plugin"},{"location":"setup/#if-you-have-a-buildsrc-module","text":"If you use the buildSrc module and have dependencies declared in the buildSrc/build.gradle[.kts] file, you probably want to use refreshVersions there as well. The setup is the same: buildSrc/settings.gradle.kts pluginManagement { plugins { id ( \"de.fayard.refreshVersions\" ) version \"0.21.0\" } } plugins { id ( \"de.fayard.refreshVersions\" ) } buildSrc/settings.gradle pluginManagement { plugins { id 'de.fayard.refreshVersions' version '0.21.0' } } plugins { id 'de.fayard.refreshVersions' }","title":"If you have a buildSrc module"},{"location":"setup/#if-you-use-groovy-dsl-ie-buildgradle-files-not-kts","text":"Auto-completion for dependency notations won\u2019t work out of the box. A workaround is to configure the plugin in the buildSrc module (create the directory if it doesn\u2019t exist yet): buildSrc/settings.gradle pluginManagement { plugins { id 'de.fayard.refreshVersions' version '0.21.0' } } plugins { id 'de.fayard.refreshVersions' }","title":"If you use Groovy DSL, i.e. build.gradle files (not kts)"},{"location":"setup/#if-you-have-a-compositeincluded-build","text":"Sharing used versions with included builds is not supported at the moment. If you need/want this feature, please vote with a \ud83d\udc4d on this issue , subscribe to it, and tell us about your use case, to help us prioritize.","title":"If you have a composite/included build"},{"location":"setup/#if-you-want-to-use-a-snapshot-version","text":"settings.gradle.kts pluginManagement { repositories { gradlePluginPortal () maven ( \"https://s01.oss.sonatype.org/content/repositories/snapshots\" ) } } plugins { // See https://jmfayard.github.io/refreshVersions id ( \"de.fayard.refreshVersions\" ) version \"0.21.1-SNAPSHOT\" } settings.gradle pluginManagement { repositories { gradlePluginPortal () maven { url 'https://s01.oss.sonatype.org/content/repositories/snapshots' } } } plugins { // See https://jmfayard.github.io/refreshVersions id 'de.fayard.refreshVersions' version '0.21.1-SNAPSHOT' }","title":"If you want to use a snapshot version"},{"location":"setup/#configure-the-plugin","text":"There is no required configuration! There are some options which can be configured in the refreshVersions { } block. If you are curious about what are the available options, you can use auto-complete (you can also type this. before to filter the results).","title":"Configure the plugin"},{"location":"setup/#earlier-versions","text":"","title":"Earlier versions"},{"location":"setup/#if-you-are-upgrading-from-the-buildsrcversions-plugin","text":"Before refreshVersions, there was the plugin buildSrcVersions . If your project is using it, remove all its configuration from the top build.gradle[.kts] file to avoid any clashes between the two plugins: build.gradle.kts -plugins { - id(\"de.fayard.buildSrcVersions\") version \"0.3.2\" -} -buildSrcVersions { - someOption = \"somevalue\" -} Then, enable buildSrcLibs as such: settings.gradle.kts plugins { // See https://jmfayard.github.io/refreshVersions id ( \"de.fayard.refreshVersions\" ) version \"0.21.0\" } refreshVersions { enableBuildSrcLibs () // <-- Add this } settings.gradle plugins { // See https://jmfayard.github.io/refreshVersions id 'de.fayard.refreshVersions' version '0.21.0' } refreshVersions { enableBuildSrcLibs () // <-- Add this } Read more: gradle buildSrcVersions .","title":"If you are upgrading from the buildSrcVersions plugin"},{"location":"setup/#next-steps","text":"You did it! refreshVersions is now properly setup. Now, you might want to: Migrate your project . Add new dependencies . Update dependencies .","title":"Next steps"},{"location":"update-dependencies/","text":"Update dependencies \u00b6 The core feature is gradle refreshVersions is that it will lookup automatically for available updates for all the dependencies that it manages. This is done in three small steps: 1. Run the refreshVersions Gradle task \u00b6 Run the refreshVersions gradle task on the root project: ./gradlew refreshVersions Hint: You don\u2019t need to leave the IDE to run a Gradle task. IntelliJ has a handy action named \u201cExecute Gradle Task\u201d: Gradle refreshVersions is fast: it usually takes less than 10 seconds to execute on relatively big projects. 2. Apply the updates you want to \u00b6 Open the versions.properties file. Let say you have this initial state: After you have run the refreshVersions task, you will see the available updates as comments : Why as comments? \u00b6 Looking for available updates is certainly a job best done by a computer program (instead of you doing the monkey job of googling, clicking and scrolling for every single used dependency). However, the decision of whether to upgrade or not, when, and towards which version, is best decided by the developers responsible like you. Edit the versions.properties file \u00b6 If you decide to update, just replace the previous version with the update: If you decide to not update for now, you can leave the comments there. They will not affect your build, and will serve as a reminder to revisit upgrading these dependencies later. They also allow you to glance at how behind the dependencies are, which is a way to estimate the technical debt of the project regarding the dependencies upgrades. If you want to delete these comments, it\u2019s possible too, and it\u2019s safe. Running the refreshVersions task will bring them back (plus any newer available update). 3. Perform a Gradle sync/reload \u00b6 The file versions.properties is part of the Gradle build. Consequently, after you have edited it, you need to ensure the IDE gets the changes. The action to do it have a different name depending on the IDE: IntelliJ IDEA: Run the \u201cReload all Gradle projects\u201d action (via ctrl / cmd + shift + A ), or click the refresh arrows in the Gradle tool window Android Studio: Run the \u201cSync Project with Gradle Files\u201d action (via ctrl / cmd + shift + A ), or click the elephant + arrow icon in the toolbar. At that point, you probably want to: \u23ed Migrate deprecated symbols (if any) \ud83d\udd28 Ensure the codebase still builds properly \u2705 Ensure the tests still run properly \ud83d\udd75\ufe0f\u200d\u2640\ufe0f Do manual testing if needed \u2705 Commit when appropriate \ud83d\udc9d Become our sponsor to thank us for the time saved \ud83d\ude09 Filter which versions are added to versions.properties \u00b6 Maybe you don\u2019t want alpha/beta versions to show up in versions.properties . This is easy to configure with a rejectVersionIf { ... } predicate: settings.gradle.kts refreshVersions { rejectVersionIf { candidate . stabilityLevel != StabilityLevel . Stable } } settings.gradle refreshVersions { rejectVersionIf { candidate . stabilityLevel != StabilityLevel . Stable } } A perhaps better approach is to display development versions only if you are already using a development version at least as stable: settings.gradle.kts refreshVersions { rejectVersionIf { candidate . stabilityLevel . isLessStableThan ( current . stabilityLevel ) } } settings.gradle refreshVersions { rejectVersionIf { candidate . stabilityLevel . isLessStableThan ( current . stabilityLevel ) } } rejectVersionsIf { ...} is pretty flexible, you can also use it to ban versions from specific version keys: settings.gradle.kts refreshVersions { rejectVersionIf { val blacklist = listOf ( \"version.retrofit\" , \"version.okhttp3\" ) versionKey in blacklist } } settings.gradle refreshVersions { rejectVersionIf { def blacklist = [ \"version.retrofit\" , \"version.okhttp3\" ] versionKey in blacklist } } Or if you prefer for dependencies with specific maven coordinates: settings.gradle.kts refreshVersions { rejectVersionIf { val blacklist = listOf ( \"com.squareup.retrofit\" , \"com.squareup.okhttp3\" ) moduleId . group in blacklist } } settings.gradle refreshVersions { rejectVersionIf { def blacklist = [ \"com.squareup.retrofit\" , \"com.squareup.okhttp3\" ] moduleId . group in blacklist } } You can also combine all of the above to match your particular needs!","title":"Update Dependencies"},{"location":"update-dependencies/#update-dependencies","text":"The core feature is gradle refreshVersions is that it will lookup automatically for available updates for all the dependencies that it manages. This is done in three small steps:","title":"Update dependencies"},{"location":"update-dependencies/#1-run-the-refreshversions-gradle-task","text":"Run the refreshVersions gradle task on the root project: ./gradlew refreshVersions Hint: You don\u2019t need to leave the IDE to run a Gradle task. IntelliJ has a handy action named \u201cExecute Gradle Task\u201d: Gradle refreshVersions is fast: it usually takes less than 10 seconds to execute on relatively big projects.","title":"1. Run the refreshVersions Gradle task"},{"location":"update-dependencies/#2-apply-the-updates-you-want-to","text":"Open the versions.properties file. Let say you have this initial state: After you have run the refreshVersions task, you will see the available updates as comments :","title":"2. Apply the updates you want to"},{"location":"update-dependencies/#why-as-comments","text":"Looking for available updates is certainly a job best done by a computer program (instead of you doing the monkey job of googling, clicking and scrolling for every single used dependency). However, the decision of whether to upgrade or not, when, and towards which version, is best decided by the developers responsible like you.","title":"Why as comments?"},{"location":"update-dependencies/#edit-the-versionsproperties-file","text":"If you decide to update, just replace the previous version with the update: If you decide to not update for now, you can leave the comments there. They will not affect your build, and will serve as a reminder to revisit upgrading these dependencies later. They also allow you to glance at how behind the dependencies are, which is a way to estimate the technical debt of the project regarding the dependencies upgrades. If you want to delete these comments, it\u2019s possible too, and it\u2019s safe. Running the refreshVersions task will bring them back (plus any newer available update).","title":"Edit the versions.properties file"},{"location":"update-dependencies/#3-perform-a-gradle-syncreload","text":"The file versions.properties is part of the Gradle build. Consequently, after you have edited it, you need to ensure the IDE gets the changes. The action to do it have a different name depending on the IDE: IntelliJ IDEA: Run the \u201cReload all Gradle projects\u201d action (via ctrl / cmd + shift + A ), or click the refresh arrows in the Gradle tool window Android Studio: Run the \u201cSync Project with Gradle Files\u201d action (via ctrl / cmd + shift + A ), or click the elephant + arrow icon in the toolbar. At that point, you probably want to: \u23ed Migrate deprecated symbols (if any) \ud83d\udd28 Ensure the codebase still builds properly \u2705 Ensure the tests still run properly \ud83d\udd75\ufe0f\u200d\u2640\ufe0f Do manual testing if needed \u2705 Commit when appropriate \ud83d\udc9d Become our sponsor to thank us for the time saved \ud83d\ude09","title":"3. Perform a Gradle sync/reload"},{"location":"update-dependencies/#filter-which-versions-are-added-to-versionsproperties","text":"Maybe you don\u2019t want alpha/beta versions to show up in versions.properties . This is easy to configure with a rejectVersionIf { ... } predicate: settings.gradle.kts refreshVersions { rejectVersionIf { candidate . stabilityLevel != StabilityLevel . Stable } } settings.gradle refreshVersions { rejectVersionIf { candidate . stabilityLevel != StabilityLevel . Stable } } A perhaps better approach is to display development versions only if you are already using a development version at least as stable: settings.gradle.kts refreshVersions { rejectVersionIf { candidate . stabilityLevel . isLessStableThan ( current . stabilityLevel ) } } settings.gradle refreshVersions { rejectVersionIf { candidate . stabilityLevel . isLessStableThan ( current . stabilityLevel ) } } rejectVersionsIf { ...} is pretty flexible, you can also use it to ban versions from specific version keys: settings.gradle.kts refreshVersions { rejectVersionIf { val blacklist = listOf ( \"version.retrofit\" , \"version.okhttp3\" ) versionKey in blacklist } } settings.gradle refreshVersions { rejectVersionIf { def blacklist = [ \"version.retrofit\" , \"version.okhttp3\" ] versionKey in blacklist } } Or if you prefer for dependencies with specific maven coordinates: settings.gradle.kts refreshVersions { rejectVersionIf { val blacklist = listOf ( \"com.squareup.retrofit\" , \"com.squareup.okhttp3\" ) moduleId . group in blacklist } } settings.gradle refreshVersions { rejectVersionIf { def blacklist = [ \"com.squareup.retrofit\" , \"com.squareup.okhttp3\" ] moduleId . group in blacklist } } You can also combine all of the above to match your particular needs!","title":"Filter which versions are added to versions.properties"},{"location":"contributing/before-you-contribute/","text":"Before you contribute \u00b6 Please, in order to not waste your efforts, your time, and our time, before working on any contribution, take a little time to read the relevant parts of the contributing guide. Code of Conduct \u00b6 First, we have a very simple code of conduct that you need to follow while interacting on this repo: Whenever you are about to post or commit, ask yourself \u201cWould an idiot do that?\u201d, and if they would, do not do that thing. https://youtu.be/KFwUcEwD4l4 Use this Code of Conduct as you like in your own projects and organizations. Q & A \u00b6 Q: What about breathing? A: The behavior must be exclusive to idiocy. General considerations \u00b6 Note: If you only want to improve the docs, you can skip the rest of this page and jump right on the documentation specific contributing guide . Reliability \u00b6 refreshVersions is used by a lot of different projects, and it shall be as reliable as possible, especially since it takes part in the build process of these projects and could break it in case of a bug. As a consequence, we strive to keep its quality as high as we can, and we actively avoid regressions and unreliable code. Sometimes, that might mean not adding a feature because of its impact, or the risks for end projects. Please, when submitting a feature request or a contribution, take some time to think about the implications on projects other than yours. Compatibility \u00b6 Also, refreshVersions being a long term project, we do our best to not break the builds of our users on upgrade, so for any new feature or change, we shall have way to introduce it in a compatible way. Note that as a Gradle plugin, we have the ability to automate migration tasks if needed, but it cannot always apply. Submitting issues \u00b6 If you want to report an issue or submit a feature request, see this guide to help us address it as quickly as possible. Submitting PRs \u00b6 Unless it\u2019s the special case of minor documentation improvement, please, do not start working on a PR before you\u2019re assigned via the corresponding issue. Not doing so might lead to overlapping efforts, and it\u2019s less likely we would accept it. If you have been assigned an issue, if you are a maintainer of this project or if you just want to play with the project on your own, first, see how to set up the dev environment properly , as the IDE will not get it right on its own. Once you\u2019ve ensured this is set up correctly, you\u2019ll need to follow our development process . It has the information you need to make a successful contribution, regardless of the type of change.","title":"Before you contribute"},{"location":"contributing/before-you-contribute/#before-you-contribute","text":"Please, in order to not waste your efforts, your time, and our time, before working on any contribution, take a little time to read the relevant parts of the contributing guide.","title":"Before you contribute"},{"location":"contributing/before-you-contribute/#code-of-conduct","text":"First, we have a very simple code of conduct that you need to follow while interacting on this repo: Whenever you are about to post or commit, ask yourself \u201cWould an idiot do that?\u201d, and if they would, do not do that thing. https://youtu.be/KFwUcEwD4l4 Use this Code of Conduct as you like in your own projects and organizations.","title":"Code of Conduct"},{"location":"contributing/before-you-contribute/#q-a","text":"Q: What about breathing? A: The behavior must be exclusive to idiocy.","title":"Q &amp; A"},{"location":"contributing/before-you-contribute/#general-considerations","text":"Note: If you only want to improve the docs, you can skip the rest of this page and jump right on the documentation specific contributing guide .","title":"General considerations"},{"location":"contributing/before-you-contribute/#reliability","text":"refreshVersions is used by a lot of different projects, and it shall be as reliable as possible, especially since it takes part in the build process of these projects and could break it in case of a bug. As a consequence, we strive to keep its quality as high as we can, and we actively avoid regressions and unreliable code. Sometimes, that might mean not adding a feature because of its impact, or the risks for end projects. Please, when submitting a feature request or a contribution, take some time to think about the implications on projects other than yours.","title":"Reliability"},{"location":"contributing/before-you-contribute/#compatibility","text":"Also, refreshVersions being a long term project, we do our best to not break the builds of our users on upgrade, so for any new feature or change, we shall have way to introduce it in a compatible way. Note that as a Gradle plugin, we have the ability to automate migration tasks if needed, but it cannot always apply.","title":"Compatibility"},{"location":"contributing/before-you-contribute/#submitting-issues","text":"If you want to report an issue or submit a feature request, see this guide to help us address it as quickly as possible.","title":"Submitting issues"},{"location":"contributing/before-you-contribute/#submitting-prs","text":"Unless it\u2019s the special case of minor documentation improvement, please, do not start working on a PR before you\u2019re assigned via the corresponding issue. Not doing so might lead to overlapping efforts, and it\u2019s less likely we would accept it. If you have been assigned an issue, if you are a maintainer of this project or if you just want to play with the project on your own, first, see how to set up the dev environment properly , as the IDE will not get it right on its own. Once you\u2019ve ensured this is set up correctly, you\u2019ll need to follow our development process . It has the information you need to make a successful contribution, regardless of the type of change.","title":"Submitting PRs"},{"location":"contributing/improving-docs/","text":"Improving docs \u00b6 Docs are powered by MKDocs \u00b6 The documentation of refreshVersions is published on a website accessible via this url: https://jmfayard.github.io/refreshVersions . It is generated with MKDocs from Markdown files. The variant of Markdown used in MKDocs has useful additional features that we use: - \u201cVariables\u201d interpolation, useful for long urls repeated in the doc. - Automatic generation of table of contents based on headings. Where is the doc source \u00b6 A bunch of things are defined in the mkdocs.yml file (located at the root of the repo): The structure of the documentation website is under the nav key. Under the extra key, we have common text snippets (example usage: {{link.github}} ) Website metadata is defined at the top of the file (you probably don\u2019t need to touch it) Theme and MKDocs configuration The content of the documentation itself is in the docs directory where you can find Markdown files and images in the img directory. Edit the doc \u00b6 Before starting any work, create a branch in your fork that is based on the release branch . Please, avoid non-improvements such as adding typos, or spelling errors. Also, try to keep the language simple, non-ambiguous, and explicit enough, so all of our users can understand it. \ud83d\ude4f View your changes \u00b6 Run one of the following commands, to ensure you have the tools to build the website locally: pip3 install -r docs/requirements.txt pip install -r docs/requirements.txt Note: on Linux and macOS, pip3 is most likely already installed. On Windows, you might want to install anaconda/Python to get it. Start the local server using the mkdocs serve command. You\u2019ll quickly see a link appear in the console to view it in your default browser. Any saved changes will refresh the page automatically if the right one is open in the browser. Once you\u2019re done, you can close the tab, and quit the local server ( ctrl + C ). Submit your changes \u00b6 Once you\u2019re done, please commit your changes with a clear title and message that mentions what changed in simple terms, then submit the pull request on GitHub.","title":"Improving docs"},{"location":"contributing/improving-docs/#improving-docs","text":"","title":"Improving docs"},{"location":"contributing/improving-docs/#docs-are-powered-by-mkdocs","text":"The documentation of refreshVersions is published on a website accessible via this url: https://jmfayard.github.io/refreshVersions . It is generated with MKDocs from Markdown files. The variant of Markdown used in MKDocs has useful additional features that we use: - \u201cVariables\u201d interpolation, useful for long urls repeated in the doc. - Automatic generation of table of contents based on headings.","title":"Docs are powered by MKDocs"},{"location":"contributing/improving-docs/#where-is-the-doc-source","text":"A bunch of things are defined in the mkdocs.yml file (located at the root of the repo): The structure of the documentation website is under the nav key. Under the extra key, we have common text snippets (example usage: {{link.github}} ) Website metadata is defined at the top of the file (you probably don\u2019t need to touch it) Theme and MKDocs configuration The content of the documentation itself is in the docs directory where you can find Markdown files and images in the img directory.","title":"Where is the doc source"},{"location":"contributing/improving-docs/#edit-the-doc","text":"Before starting any work, create a branch in your fork that is based on the release branch . Please, avoid non-improvements such as adding typos, or spelling errors. Also, try to keep the language simple, non-ambiguous, and explicit enough, so all of our users can understand it. \ud83d\ude4f","title":"Edit the doc"},{"location":"contributing/improving-docs/#view-your-changes","text":"Run one of the following commands, to ensure you have the tools to build the website locally: pip3 install -r docs/requirements.txt pip install -r docs/requirements.txt Note: on Linux and macOS, pip3 is most likely already installed. On Windows, you might want to install anaconda/Python to get it. Start the local server using the mkdocs serve command. You\u2019ll quickly see a link appear in the console to view it in your default browser. Any saved changes will refresh the page automatically if the right one is open in the browser. Once you\u2019re done, you can close the tab, and quit the local server ( ctrl + C ).","title":"View your changes"},{"location":"contributing/improving-docs/#submit-your-changes","text":"Once you\u2019re done, please commit your changes with a clear title and message that mentions what changed in simple terms, then submit the pull request on GitHub.","title":"Submit your changes"},{"location":"contributing/submitting-issues/","text":"Submitting issues \u00b6 Check for existing issues first \u00b6 Be it a bug report or a feature request, someone else might have already submitted it, so, please, start by searching for existing issues. If you find an existing one, please vote for it with the thumbs up emoji (\ud83d\udc4d). Also, if you find that some info is missing for us, and you can provide it, do it as it might help to resolve it faster. You can also influence the priorities if the impact on your project is high by telling us in the comments, but please avoid useless comments like \u201c+1\u201d, and make sure you stay constructive . Bug reports \u00b6 Please, before writing a report, make sure the bug has not been fixed in the latest version of refreshVersions. In your report, provide the needed details to reproduce the issue, and not more than that. However, if the doesn\u2019t reproduce consistently, please report it anyway, and give as many details as you can for us to investigate. If you know any workarounds, please mention them. Finally, make sure you stay constructive in your report. Feature requests \u00b6 When submitting a feature request, please explain why you need the feature, what is your use case , and any context that might help understand it. These are more important that your solution suggestion, even if ideas are always welcome. If there\u2019s an alternative to what you want, please show what it is.","title":"Submitting issues"},{"location":"contributing/submitting-issues/#submitting-issues","text":"","title":"Submitting issues"},{"location":"contributing/submitting-issues/#check-for-existing-issues-first","text":"Be it a bug report or a feature request, someone else might have already submitted it, so, please, start by searching for existing issues. If you find an existing one, please vote for it with the thumbs up emoji (\ud83d\udc4d). Also, if you find that some info is missing for us, and you can provide it, do it as it might help to resolve it faster. You can also influence the priorities if the impact on your project is high by telling us in the comments, but please avoid useless comments like \u201c+1\u201d, and make sure you stay constructive .","title":"Check for existing issues first"},{"location":"contributing/submitting-issues/#bug-reports","text":"Please, before writing a report, make sure the bug has not been fixed in the latest version of refreshVersions. In your report, provide the needed details to reproduce the issue, and not more than that. However, if the doesn\u2019t reproduce consistently, please report it anyway, and give as many details as you can for us to investigate. If you know any workarounds, please mention them. Finally, make sure you stay constructive in your report.","title":"Bug reports"},{"location":"contributing/submitting-issues/#feature-requests","text":"When submitting a feature request, please explain why you need the feature, what is your use case , and any context that might help understand it. These are more important that your solution suggestion, even if ideas are always welcome. If there\u2019s an alternative to what you want, please show what it is.","title":"Feature requests"},{"location":"contributing/submitting-prs/dependency-notations-updates/","text":"Submitting dependency notations \u00b6 We want to provide dependency notations for more popular libraries. Want to contribute some? Here is what a dependency notation should look like: @file : Suppress ( \"PackageDirectoryMismatch\" , \"SpellCheckingInspection\" , \"unused\" ) // 1 import de.fayard.refreshVersions.core.DependencyGroup import org.gradle.api.Incubating import org.gradle.kotlin.dsl.IsNotADependency /** // 2 * painless Kotlin dependency injection * * - [Official website here](https://kodein.org/di/) * - GitHub page: [Kodein-Framework/Kodein-DI](https://github.com/Kodein-Framework/Kodein-DI) * - [GitHub Releases here](https://github.com/Kodein-Framework/Kodein-DI/releases) */ @Incubating object Kodein : IsNotADependency { // 3 val di = DI // 4 object DI : DependencyGroup ( // 5 group = \"org.kodein.di\" , // 6 usePlatformConstraints = false , // 7 rawRule = \"\"\" org.kodein.di:kodein-di(-*) ^^^^^^^^^ \"\"\" . trimIndent () // 8 ) { val bom = module ( \"kodein-bom\" , isBom = true ) // 9 val js = module ( \"kodein-di-js\" ) // 10 val androidx = module ( \"kodein-di-framework-android-x\" ) } } What you need to know: We use no package on purpose - and suppress the corresponding warning - so that users don\u2019t have to import the dependency notation. We provide a KDoc with a description of what the library does, a link to GitHub, and a link to the documentation. Please, keep the exact same style for consistency. We tag the objects with IsNotADependency , so that the IDE shows an error if the user tries to do implementation(Kodein) . We support Gradle build scripts in both Kotlin and Groovy. Kodein.DI works in Kotlin, but not in Groovy. That\u2019s why we have the property Kotlin.di , which works in both. We use the base class DependencyGroup to define a group of dependency notations. Note that this class also has the IsNotADependency marker interface. If you want the object or sub-group to be a dependency notation itself, use the DependencyNotationAndGroup class instead. The maven group that will be used for all the modules of this DependencyGroup (or DependencyNotationAndGroup ). If the library provides a Bill of Materials (BoM for short), or another kind of platform constraints that should always be used, we set usePlatformConstraints = true . (As you can see, in the case of the example, it\u2019s not made mandatory.) All dependency notations with a name like org.kodein.di:kodein-di(-*) will use the same version version.kodein.di because we defined an artifact rule. To learn more about those rules, have a look here . DependencyGroup and DependencyNotationAndGroup have first class support for BoMs via the isBom = true parameter. It sets the boolean usePlatformConstraints to true for the group and does various checks. A module is defined via the = module(\"module.name\") syntax. Three more things before you start coding: Look at Square , COIL , Http4K , Spring , Kodein , and others for inspiration. Try to not forget any artifact! . One of the best ways to do that is to open an issue in the project of the library for which you contribute dependency notations. Run the unit tests! There are multiple checks that are done to prevent the most common mistakes.","title":"Dependency notations"},{"location":"contributing/submitting-prs/dependency-notations-updates/#submitting-dependency-notations","text":"We want to provide dependency notations for more popular libraries. Want to contribute some? Here is what a dependency notation should look like: @file : Suppress ( \"PackageDirectoryMismatch\" , \"SpellCheckingInspection\" , \"unused\" ) // 1 import de.fayard.refreshVersions.core.DependencyGroup import org.gradle.api.Incubating import org.gradle.kotlin.dsl.IsNotADependency /** // 2 * painless Kotlin dependency injection * * - [Official website here](https://kodein.org/di/) * - GitHub page: [Kodein-Framework/Kodein-DI](https://github.com/Kodein-Framework/Kodein-DI) * - [GitHub Releases here](https://github.com/Kodein-Framework/Kodein-DI/releases) */ @Incubating object Kodein : IsNotADependency { // 3 val di = DI // 4 object DI : DependencyGroup ( // 5 group = \"org.kodein.di\" , // 6 usePlatformConstraints = false , // 7 rawRule = \"\"\" org.kodein.di:kodein-di(-*) ^^^^^^^^^ \"\"\" . trimIndent () // 8 ) { val bom = module ( \"kodein-bom\" , isBom = true ) // 9 val js = module ( \"kodein-di-js\" ) // 10 val androidx = module ( \"kodein-di-framework-android-x\" ) } } What you need to know: We use no package on purpose - and suppress the corresponding warning - so that users don\u2019t have to import the dependency notation. We provide a KDoc with a description of what the library does, a link to GitHub, and a link to the documentation. Please, keep the exact same style for consistency. We tag the objects with IsNotADependency , so that the IDE shows an error if the user tries to do implementation(Kodein) . We support Gradle build scripts in both Kotlin and Groovy. Kodein.DI works in Kotlin, but not in Groovy. That\u2019s why we have the property Kotlin.di , which works in both. We use the base class DependencyGroup to define a group of dependency notations. Note that this class also has the IsNotADependency marker interface. If you want the object or sub-group to be a dependency notation itself, use the DependencyNotationAndGroup class instead. The maven group that will be used for all the modules of this DependencyGroup (or DependencyNotationAndGroup ). If the library provides a Bill of Materials (BoM for short), or another kind of platform constraints that should always be used, we set usePlatformConstraints = true . (As you can see, in the case of the example, it\u2019s not made mandatory.) All dependency notations with a name like org.kodein.di:kodein-di(-*) will use the same version version.kodein.di because we defined an artifact rule. To learn more about those rules, have a look here . DependencyGroup and DependencyNotationAndGroup have first class support for BoMs via the isBom = true parameter. It sets the boolean usePlatformConstraints to true for the group and does various checks. A module is defined via the = module(\"module.name\") syntax. Three more things before you start coding: Look at Square , COIL , Http4K , Spring , Kodein , and others for inspiration. Try to not forget any artifact! . One of the best ways to do that is to open an issue in the project of the library for which you contribute dependency notations. Run the unit tests! There are multiple checks that are done to prevent the most common mistakes.","title":"Submitting dependency notations"},{"location":"contributing/submitting-prs/dev-env/","text":"Dev environment for contributors \u00b6 Setting up the project in your IDE \u00b6 Get the right IDE \u00b6 We recommend using the most recent version of IntelliJ IDEA to contribute to this project (consider 2020.3 or newer). Prepare your fork \u00b6 Fork this project from GitHub if not already done. Clone your fork locally. Checkout the main branch. If your fork is not fresh, ensure its main branch is up to date with upstream: Run the git fetch upstream command. Run the git merge upstream/main command. Create a new branch based on main with a name describing what it is about. Import the \u201cplugins\u201d Gradle project \u00b6 Locate the plugins/settings.gradle.kts file in the \u201cProject\u201d tool window. Right-click on it to open the contextual menu. Select \u201cImport Gradle Project\u201d. Publish the current version locally \u00b6 This step is required for the samples to work afterwards and enable you to test your changes. Ensure the version in the plugins/version.txt file ends with -SNAPSHOT to avoid overlapping a published version. In the \u201cGradle\u201d tool window, or from the terminal, run the publishToMavenLocal task. Testing changes locally \u00b6 Import the samples to test the changes \u00b6 We have multiple samples to test integration in different scenarios. Here are their names, you can find them in so-named directories in the repo: sample-kotlin sample-groovy sample-android sample-multi-modules The first two samples (sample-kotlin and sample-groovy) are the ones you should always test your changes on. They are lightweight, so it\u2019s quick to set up and iterate with. For edge cases in multi-modules projects and for Android specific things, the two other samples are the ones to test your changes on. To import a sample, just like you did for the plugins Gradle project, right-click on the settings.gradle or settings.gradle.kts file and select the \u201cImport Gradle Project\u201d option. Testing in your own project \u00b6 To test your changes in your own project locally, in the settings.gradle or settings.gradle.kts file, you need to add the mavenLocal() repository in the pluginManagement section (create the block at the top of the file if you don\u2019t already have one): pluginManagement { repositories { gradlePluginPortal () // Needed to keep using the Gradle plugin portal for other plugins. mavenLocal () // Also use mavenLocal for local-only versions. } } Once you\u2019re done, you can replace the version with the snapshot version (e.g. 0.9.8 -> 0.9.9-SNAPSHOT ) and test your changes.","title":"Dev environment"},{"location":"contributing/submitting-prs/dev-env/#dev-environment-for-contributors","text":"","title":"Dev environment for contributors"},{"location":"contributing/submitting-prs/dev-env/#setting-up-the-project-in-your-ide","text":"","title":"Setting up the project in your IDE"},{"location":"contributing/submitting-prs/dev-env/#get-the-right-ide","text":"We recommend using the most recent version of IntelliJ IDEA to contribute to this project (consider 2020.3 or newer).","title":"Get the right IDE"},{"location":"contributing/submitting-prs/dev-env/#prepare-your-fork","text":"Fork this project from GitHub if not already done. Clone your fork locally. Checkout the main branch. If your fork is not fresh, ensure its main branch is up to date with upstream: Run the git fetch upstream command. Run the git merge upstream/main command. Create a new branch based on main with a name describing what it is about.","title":"Prepare your fork"},{"location":"contributing/submitting-prs/dev-env/#import-the-plugins-gradle-project","text":"Locate the plugins/settings.gradle.kts file in the \u201cProject\u201d tool window. Right-click on it to open the contextual menu. Select \u201cImport Gradle Project\u201d.","title":"Import the \"plugins\" Gradle project"},{"location":"contributing/submitting-prs/dev-env/#publish-the-current-version-locally","text":"This step is required for the samples to work afterwards and enable you to test your changes. Ensure the version in the plugins/version.txt file ends with -SNAPSHOT to avoid overlapping a published version. In the \u201cGradle\u201d tool window, or from the terminal, run the publishToMavenLocal task.","title":"Publish the current version locally"},{"location":"contributing/submitting-prs/dev-env/#testing-changes-locally","text":"","title":"Testing changes locally"},{"location":"contributing/submitting-prs/dev-env/#import-the-samples-to-test-the-changes","text":"We have multiple samples to test integration in different scenarios. Here are their names, you can find them in so-named directories in the repo: sample-kotlin sample-groovy sample-android sample-multi-modules The first two samples (sample-kotlin and sample-groovy) are the ones you should always test your changes on. They are lightweight, so it\u2019s quick to set up and iterate with. For edge cases in multi-modules projects and for Android specific things, the two other samples are the ones to test your changes on. To import a sample, just like you did for the plugins Gradle project, right-click on the settings.gradle or settings.gradle.kts file and select the \u201cImport Gradle Project\u201d option.","title":"Import the samples to test the changes"},{"location":"contributing/submitting-prs/dev-env/#testing-in-your-own-project","text":"To test your changes in your own project locally, in the settings.gradle or settings.gradle.kts file, you need to add the mavenLocal() repository in the pluginManagement section (create the block at the top of the file if you don\u2019t already have one): pluginManagement { repositories { gradlePluginPortal () // Needed to keep using the Gradle plugin portal for other plugins. mavenLocal () // Also use mavenLocal for local-only versions. } } Once you\u2019re done, you can replace the version with the snapshot version (e.g. 0.9.8 -> 0.9.9-SNAPSHOT ) and test your changes.","title":"Testing in your own project"},{"location":"contributing/submitting-prs/dev-process/","text":"Development process \u00b6 Note: If the contribution you want to make is updating, adding or removing dependency notations, you can skip the rest of this document and go directly to the specific guide . Better safe than sorry \u00b6 Fixing bugs \u00b6 Please, make sure your bug fix doesn\u2019t introduce new bugs before submitting. Changing behavior of existing features \u00b6 Behavior changes might introduce bugs, and these might not be caught until users face them. Consequently, whenever possible, we keep the old implementation and add the new one side by side, with a feature flag controlling which one is being used. That allows our users to switch-off changes that might interfere with their project setup. For changes that break the API or setup of some or all projects, we provide automatic or semi-automatic migration on upgrade. If it\u2019s needed, we will let you know in the corresponding issue. New features \u00b6 Unless impossible, we add every new feature behind a feature-flag, so our users can disable it if it causes any problem in their project. Send a draft early \u00b6 We do not want you to spend a lot of time on a change only to realize it didn\u2019t do in the right direction for us to be able to integrate it in the project. Consequently, we are asking you, especially for new features, to send us an early draft PR that we can give early feedback on before you complete your contribution. Check nothing is broken \u00b6 Before committing anything, please check nothing is broken. \ud83d\ude4f Ways to do it are running the check task against the plugins project, as well as ensuring the sample projects still build, and behave properly in the IDE with your changes. Use proper commit messages \u00b6 If you don\u2019t, we will squash your PR into one commit on merge. You can reach for help \u00b6 Feel free to ask for any help in the PR comments or in the corresponding issue. Submitting the PR \u00b6 In the text of the PR, make sure to reference the corresponding issue properly. Examples: \u00b6 For bug fixes: Fixes #456 For new features or changes: Resolves #123","title":"Development process"},{"location":"contributing/submitting-prs/dev-process/#development-process","text":"Note: If the contribution you want to make is updating, adding or removing dependency notations, you can skip the rest of this document and go directly to the specific guide .","title":"Development process"},{"location":"contributing/submitting-prs/dev-process/#better-safe-than-sorry","text":"","title":"Better safe than sorry"},{"location":"contributing/submitting-prs/dev-process/#fixing-bugs","text":"Please, make sure your bug fix doesn\u2019t introduce new bugs before submitting.","title":"Fixing bugs"},{"location":"contributing/submitting-prs/dev-process/#changing-behavior-of-existing-features","text":"Behavior changes might introduce bugs, and these might not be caught until users face them. Consequently, whenever possible, we keep the old implementation and add the new one side by side, with a feature flag controlling which one is being used. That allows our users to switch-off changes that might interfere with their project setup. For changes that break the API or setup of some or all projects, we provide automatic or semi-automatic migration on upgrade. If it\u2019s needed, we will let you know in the corresponding issue.","title":"Changing behavior of existing features"},{"location":"contributing/submitting-prs/dev-process/#new-features","text":"Unless impossible, we add every new feature behind a feature-flag, so our users can disable it if it causes any problem in their project.","title":"New features"},{"location":"contributing/submitting-prs/dev-process/#send-a-draft-early","text":"We do not want you to spend a lot of time on a change only to realize it didn\u2019t do in the right direction for us to be able to integrate it in the project. Consequently, we are asking you, especially for new features, to send us an early draft PR that we can give early feedback on before you complete your contribution.","title":"Send a draft early"},{"location":"contributing/submitting-prs/dev-process/#check-nothing-is-broken","text":"Before committing anything, please check nothing is broken. \ud83d\ude4f Ways to do it are running the check task against the plugins project, as well as ensuring the sample projects still build, and behave properly in the IDE with your changes.","title":"Check nothing is broken"},{"location":"contributing/submitting-prs/dev-process/#use-proper-commit-messages","text":"If you don\u2019t, we will squash your PR into one commit on merge.","title":"Use proper commit messages"},{"location":"contributing/submitting-prs/dev-process/#you-can-reach-for-help","text":"Feel free to ask for any help in the PR comments or in the corresponding issue.","title":"You can reach for help"},{"location":"contributing/submitting-prs/dev-process/#submitting-the-pr","text":"In the text of the PR, make sure to reference the corresponding issue properly.","title":"Submitting the PR"},{"location":"contributing/submitting-prs/dev-process/#examples","text":"For bug fixes: Fixes #456 For new features or changes: Resolves #123","title":"Examples:"}]}